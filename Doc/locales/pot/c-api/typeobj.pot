# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-12 11:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr ""

#: ../../c-api/typeobj.rst:8
msgid "Perhaps one of the most important structures of the Python object system is the structure that defines a new type: the :c:type:`PyTypeObject` structure.  Type objects can be handled using any of the :c:func:`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much that's interesting to most Python applications. These objects are fundamental to how objects behave, so they are very important to the interpreter itself and to any extension module that implements new types."
msgstr ""

#: ../../c-api/typeobj.rst:16
msgid "Type objects are fairly large compared to most of the standard types. The reason for the size is that each type object stores a large number of values, mostly C function pointers, each of which implements a small part of the type's functionality.  The fields of the type object are examined in detail in this section.  The fields will be described in the order in which they occur in the structure."
msgstr ""

#: ../../c-api/typeobj.rst:23
msgid "In addition to the following quick reference, the :ref:`typedef-examples` section provides at-a-glance insight into the meaning and use of :c:type:`PyTypeObject`."
msgstr ""

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr ""

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr ""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr ""

#: ../../c-api/typeobj.rst:40
#: ../../c-api/typeobj.rst:200
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ""

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr ""

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr ""

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr ""

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr ""

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr ""

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr ""

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr ""

#: ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid "const char *"
msgstr ""

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr ""

#: ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70
#: ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90
#: ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103
#: ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107
#: ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111
#: ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117
#: ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:146
msgid "X"
msgstr ""

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ""

#: ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid "Py_ssize_t"
msgstr ""

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ""

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ""

#: ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146
#: ../../c-api/typeobj.rst:343
msgid ":c:type:`destructor`"
msgstr ""

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ""

#: ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr ""

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr ""

#: ../../c-api/typeobj.rst:54
#: ../../c-api/typeobj.rst:367
msgid ":c:type:`getattrfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:54
#: ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr ""

#: ../../c-api/typeobj.rst:54
#: ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70
#: ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90
#: ../../c-api/typeobj.rst:92
msgid "G"
msgstr ""

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr ""

#: ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:372
msgid ":c:type:`setattrfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr ""

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ""

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ""

#: ../../c-api/typeobj.rst:60
#: ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66
#: ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ""

#: ../../c-api/typeobj.rst:60
#: ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66
#: ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr ""

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ""

#: ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:365
msgid ":c:type:`reprfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr ""

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ""

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ""

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ""

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ""

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ""

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ""

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ""

#: ../../c-api/typeobj.rst:70
#: ../../c-api/typeobj.rst:401
msgid ":c:type:`hashfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr ""

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ""

#: ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:234
#: ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:437
msgid ":c:type:`ternaryfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr ""

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ""

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr ""

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ""

#: ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:378
msgid ":c:type:`getattrofunc`"
msgstr ""

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ""

#: ../../c-api/typeobj.rst:79
#: ../../c-api/typeobj.rst:383
msgid ":c:type:`setattrofunc`"
msgstr ""

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ""

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ""

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ""

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr ""

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ""

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr ""

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ""

#: ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:347
msgid ":c:type:`traverseproc`"
msgstr ""

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ""

#: ../../c-api/typeobj.rst:90
#: ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:245
#: ../../c-api/typeobj.rst:426
msgid ":c:type:`inquiry`"
msgstr ""

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ""

#: ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:403
msgid ":c:type:`richcmpfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr ""

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ""

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ""

#: ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:409
msgid ":c:type:`getiterfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr ""

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ""

#: ../../c-api/typeobj.rst:103
#: ../../c-api/typeobj.rst:411
msgid ":c:type:`iternextfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr ""

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ""

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ""

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ""

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ""

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ""

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ""

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ""

#: ../../c-api/typeobj.rst:111
#: ../../c-api/typeobj.rst:0
msgid ":c:type:`PyTypeObject` *"
msgstr ""

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr ""

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ""

#: ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136
#: ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:338
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:353
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:365
#: ../../c-api/typeobj.rst:365
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:367
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:378
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:389
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:401
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:403
#: ../../c-api/typeobj.rst:409
#: ../../c-api/typeobj.rst:409
#: ../../c-api/typeobj.rst:411
#: ../../c-api/typeobj.rst:411
#: ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:428
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:437
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:443
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid ":c:type:`PyObject` *"
msgstr ""

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr ""

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ""

#: ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:389
msgid ":c:type:`descrgetfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr ""

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ""

#: ../../c-api/typeobj.rst:117
#: ../../c-api/typeobj.rst:395
msgid ":c:type:`descrsetfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr ""

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ""

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ""

#: ../../c-api/typeobj.rst:122
#: ../../c-api/typeobj.rst:359
msgid ":c:type:`initproc`"
msgstr ""

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr ""

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ""

#: ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:338
msgid ":c:type:`allocfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ""

#: ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:353
msgid ":c:type:`newfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr ""

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ""

#: ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:345
msgid ":c:type:`freefunc`"
msgstr ""

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ""

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr ""

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr ""

#: ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134
msgid "~"
msgstr ""

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr ""

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr ""

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr ""

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr ""

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr ""

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr ""

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr ""

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr ""

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr ""

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ""

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr ""

#: ../../c-api/typeobj.rst:149
msgid "If :const:`COUNT_ALLOCS` is defined then the following (internal-only) fields exist as well:"
msgstr ""

#: ../../c-api/typeobj.rst:152
msgid ":c:member:`~PyTypeObject.tp_allocs`"
msgstr ""

#: ../../c-api/typeobj.rst:153
msgid ":c:member:`~PyTypeObject.tp_frees`"
msgstr ""

#: ../../c-api/typeobj.rst:154
msgid ":c:member:`~PyTypeObject.tp_maxalloc`"
msgstr ""

#: ../../c-api/typeobj.rst:155
msgid ":c:member:`~PyTypeObject.tp_prev`"
msgstr ""

#: ../../c-api/typeobj.rst:156
msgid ":c:member:`~PyTypeObject.tp_next`"
msgstr ""

#: ../../c-api/typeobj.rst:159
msgid "A slot name in parentheses indicates it is (effectively) deprecated. Names in angle brackets should be treated as read-only. Names in square brackets are for internal use only. \"<R>\" (as a prefix) means the field is required (must be non-*NULL*)."
msgstr ""

#: ../../c-api/typeobj.rst:163
msgid "Columns:"
msgstr ""

#: ../../c-api/typeobj.rst:165
msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr ""

#: ../../c-api/typeobj.rst:167
msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr ""

#: ../../c-api/typeobj.rst:169
msgid "**\"D\"**:  default (if slot is set to *NULL*)"
msgstr ""

#: ../../c-api/typeobj.rst:179
msgid "**\"I\"**:  inheritance"
msgstr ""

#: ../../c-api/typeobj.rst:188
msgid "Note that some slots are effectively inherited through the normal attribute lookup chain."
msgstr ""

#: ../../c-api/typeobj.rst:194
msgid "sub-slots"
msgstr ""

#: ../../c-api/typeobj.rst:200
msgid "Slot"
msgstr ""

#: ../../c-api/typeobj.rst:200
msgid "special methods"
msgstr ""

#: ../../c-api/typeobj.rst:203
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ""

#: ../../c-api/typeobj.rst:203
#: ../../c-api/typeobj.rst:205
#: ../../c-api/typeobj.rst:207
#: ../../c-api/typeobj.rst:239
#: ../../c-api/typeobj.rst:241
#: ../../c-api/typeobj.rst:243
#: ../../c-api/typeobj.rst:247
#: ../../c-api/typeobj.rst:274
#: ../../c-api/typeobj.rst:278
#: ../../c-api/typeobj.rst:288
#: ../../c-api/typeobj.rst:428
msgid ":c:type:`unaryfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:203
msgid "__await__"
msgstr ""

#: ../../c-api/typeobj.rst:205
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ""

#: ../../c-api/typeobj.rst:205
msgid "__aiter__"
msgstr ""

#: ../../c-api/typeobj.rst:207
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ""

#: ../../c-api/typeobj.rst:207
msgid "__anext__"
msgstr ""

#: ../../c-api/typeobj.rst:211
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ""

#: ../../c-api/typeobj.rst:211
#: ../../c-api/typeobj.rst:214
#: ../../c-api/typeobj.rst:216
#: ../../c-api/typeobj.rst:219
#: ../../c-api/typeobj.rst:221
#: ../../c-api/typeobj.rst:224
#: ../../c-api/typeobj.rst:226
#: ../../c-api/typeobj.rst:229
#: ../../c-api/typeobj.rst:231
#: ../../c-api/typeobj.rst:249
#: ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:254
#: ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:259
#: ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:264
#: ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:269
#: ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:280
#: ../../c-api/typeobj.rst:282
#: ../../c-api/typeobj.rst:284
#: ../../c-api/typeobj.rst:286
#: ../../c-api/typeobj.rst:290
#: ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:299
#: ../../c-api/typeobj.rst:308
#: ../../c-api/typeobj.rst:319
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`binaryfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:211
msgid "__add__ __radd__"
msgstr ""

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ""

#: ../../c-api/typeobj.rst:214
#: ../../c-api/typeobj.rst:319
msgid "__iadd__"
msgstr ""

#: ../../c-api/typeobj.rst:216
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ""

#: ../../c-api/typeobj.rst:216
msgid "__sub__ __rsub__"
msgstr ""

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ""

#: ../../c-api/typeobj.rst:219
msgid "__sub__"
msgstr ""

#: ../../c-api/typeobj.rst:221
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ""

#: ../../c-api/typeobj.rst:221
msgid "__mul__ __rmul__"
msgstr ""

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ""

#: ../../c-api/typeobj.rst:224
#: ../../c-api/typeobj.rst:310
msgid "__mul__"
msgstr ""

#: ../../c-api/typeobj.rst:226
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ""

#: ../../c-api/typeobj.rst:226
msgid "__mod__ __rmod__"
msgstr ""

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ""

#: ../../c-api/typeobj.rst:229
msgid "__mod__"
msgstr ""

#: ../../c-api/typeobj.rst:231
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ""

#: ../../c-api/typeobj.rst:231
msgid "__divmod__ __rdivmod__"
msgstr ""

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ""

#: ../../c-api/typeobj.rst:234
msgid "__pow__ __rpow__"
msgstr ""

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ""

#: ../../c-api/typeobj.rst:237
msgid "__pow__"
msgstr ""

#: ../../c-api/typeobj.rst:239
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ""

#: ../../c-api/typeobj.rst:239
msgid "__neg__"
msgstr ""

#: ../../c-api/typeobj.rst:241
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ""

#: ../../c-api/typeobj.rst:241
msgid "__pos__"
msgstr ""

#: ../../c-api/typeobj.rst:243
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ""

#: ../../c-api/typeobj.rst:243
msgid "__abs__"
msgstr ""

#: ../../c-api/typeobj.rst:245
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ""

#: ../../c-api/typeobj.rst:245
msgid "__bool__"
msgstr ""

#: ../../c-api/typeobj.rst:247
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ""

#: ../../c-api/typeobj.rst:247
msgid "__invert__"
msgstr ""

#: ../../c-api/typeobj.rst:249
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ""

#: ../../c-api/typeobj.rst:249
msgid "__lshift__ __rlshift__"
msgstr ""

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ""

#: ../../c-api/typeobj.rst:252
msgid "__lshift__"
msgstr ""

#: ../../c-api/typeobj.rst:254
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ""

#: ../../c-api/typeobj.rst:254
msgid "__rshift__ __rrshift__"
msgstr ""

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ""

#: ../../c-api/typeobj.rst:257
msgid "__rshift__"
msgstr ""

#: ../../c-api/typeobj.rst:259
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ""

#: ../../c-api/typeobj.rst:259
msgid "__and__ __rand__"
msgstr ""

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ""

#: ../../c-api/typeobj.rst:262
msgid "__and__"
msgstr ""

#: ../../c-api/typeobj.rst:264
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ""

#: ../../c-api/typeobj.rst:264
msgid "__xor__ __rxor__"
msgstr ""

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ""

#: ../../c-api/typeobj.rst:267
msgid "__xor__"
msgstr ""

#: ../../c-api/typeobj.rst:269
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ""

#: ../../c-api/typeobj.rst:269
msgid "__or__ __ror__"
msgstr ""

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ""

#: ../../c-api/typeobj.rst:272
msgid "__or__"
msgstr ""

#: ../../c-api/typeobj.rst:274
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ""

#: ../../c-api/typeobj.rst:274
msgid "__int__"
msgstr ""

#: ../../c-api/typeobj.rst:276
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ""

#: ../../c-api/typeobj.rst:276
#: ../../c-api/typeobj.rst:343
#: ../../c-api/typeobj.rst:345
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:426
msgid "void *"
msgstr ""

#: ../../c-api/typeobj.rst:278
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ""

#: ../../c-api/typeobj.rst:278
msgid "__float__"
msgstr ""

#: ../../c-api/typeobj.rst:280
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ""

#: ../../c-api/typeobj.rst:280
#: ../../c-api/typeobj.rst:282
msgid "__floordiv__"
msgstr ""

#: ../../c-api/typeobj.rst:282
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ""

#: ../../c-api/typeobj.rst:284
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ""

#: ../../c-api/typeobj.rst:284
#: ../../c-api/typeobj.rst:286
msgid "__truediv__"
msgstr ""

#: ../../c-api/typeobj.rst:286
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ""

#: ../../c-api/typeobj.rst:288
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ""

#: ../../c-api/typeobj.rst:288
msgid "__index__"
msgstr ""

#: ../../c-api/typeobj.rst:290
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ""

#: ../../c-api/typeobj.rst:290
msgid "__matmul__ __rmatmul__"
msgstr ""

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ""

#: ../../c-api/typeobj.rst:293
msgid "__matmul__"
msgstr ""

#: ../../c-api/typeobj.rst:297
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ""

#: ../../c-api/typeobj.rst:297
#: ../../c-api/typeobj.rst:306
#: ../../c-api/typeobj.rst:413
msgid ":c:type:`lenfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:297
#: ../../c-api/typeobj.rst:306
msgid "__len__"
msgstr ""

#: ../../c-api/typeobj.rst:299
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ""

#: ../../c-api/typeobj.rst:299
#: ../../c-api/typeobj.rst:312
msgid "__getitem__"
msgstr ""

#: ../../c-api/typeobj.rst:301
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ""

#: ../../c-api/typeobj.rst:301
#: ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjargproc`"
msgstr ""

#: ../../c-api/typeobj.rst:301
msgid "__setitem__, __delitem__"
msgstr ""

#: ../../c-api/typeobj.rst:306
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ""

#: ../../c-api/typeobj.rst:308
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ""

#: ../../c-api/typeobj.rst:308
msgid "__add__"
msgstr ""

#: ../../c-api/typeobj.rst:310
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ""

#: ../../c-api/typeobj.rst:310
#: ../../c-api/typeobj.rst:312
#: ../../c-api/typeobj.rst:321
#: ../../c-api/typeobj.rst:443
msgid ":c:type:`ssizeargfunc`"
msgstr ""

#: ../../c-api/typeobj.rst:312
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ""

#: ../../c-api/typeobj.rst:314
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ""

#: ../../c-api/typeobj.rst:314
#: ../../c-api/typeobj.rst:448
msgid ":c:type:`ssizeobjargproc`"
msgstr ""

#: ../../c-api/typeobj.rst:314
msgid "__setitem__ __delitem__"
msgstr ""

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ""

#: ../../c-api/typeobj.rst:317
#: ../../c-api/typeobj.rst:453
msgid ":c:type:`objobjproc`"
msgstr ""

#: ../../c-api/typeobj.rst:317
msgid "__contains__"
msgstr ""

#: ../../c-api/typeobj.rst:319
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ""

#: ../../c-api/typeobj.rst:321
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ""

#: ../../c-api/typeobj.rst:321
msgid "__imul__"
msgstr ""

#: ../../c-api/typeobj.rst:325
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ""

#: ../../c-api/typeobj.rst:325
msgid ":c:func:`getbufferproc`"
msgstr ""

#: ../../c-api/typeobj.rst:327
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ""

#: ../../c-api/typeobj.rst:327
msgid ":c:func:`releasebufferproc`"
msgstr ""

#: ../../c-api/typeobj.rst:333
msgid "slot typedefs"
msgstr ""

#: ../../c-api/typeobj.rst:336
msgid "typedef"
msgstr ""

#: ../../c-api/typeobj.rst:336
msgid "Parameter Types"
msgstr ""

#: ../../c-api/typeobj.rst:336
msgid "Return Type"
msgstr ""

#: ../../c-api/typeobj.rst:343
#: ../../c-api/typeobj.rst:345
#: ../../c-api/typeobj.rst:421
msgid "void"
msgstr ""

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ""

#: ../../c-api/typeobj.rst:347
#: ../../c-api/typeobj.rst:359
#: ../../c-api/typeobj.rst:372
#: ../../c-api/typeobj.rst:383
#: ../../c-api/typeobj.rst:395
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:415
#: ../../c-api/typeobj.rst:426
#: ../../c-api/typeobj.rst:448
#: ../../c-api/typeobj.rst:453
#: ../../c-api/typeobj.rst:458
msgid "int"
msgstr ""

#: ../../c-api/typeobj.rst:401
msgid "Py_hash_t"
msgstr ""

#: ../../c-api/typeobj.rst:415
msgid ":c:type:`getbufferproc`"
msgstr ""

#: ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ""

#: ../../c-api/typeobj.rst:421
msgid ":c:type:`releasebufferproc`"
msgstr ""

#: ../../c-api/typeobj.rst:465
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr ""

#: ../../c-api/typeobj.rst:469
msgid "PyTypeObject Definition"
msgstr ""

#: ../../c-api/typeobj.rst:471
msgid "The structure definition for :c:type:`PyTypeObject` can be found in :file:`Include/object.h`.  For convenience of reference, this repeats the definition found there:"
msgstr ""

#: ../../c-api/typeobj.rst:481
msgid "PyObject Slots"
msgstr ""

#: ../../c-api/typeobj.rst:483
msgid "The type object structure extends the :c:type:`PyVarObject` structure. The :attr:`ob_size` field is used for dynamic types (created by  :func:`type_new`, usually called from a class statement). Note that :c:data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""

#: ../../c-api/typeobj.rst:493
msgid "These fields are only present when the macro ``Py_TRACE_REFS`` is defined. Their initialization to *NULL* is taken care of by the ``PyObject_HEAD_INIT`` macro.  For statically allocated objects, these fields always remain *NULL*. For dynamically allocated objects, these two fields are used to link the object into a doubly-linked list of *all* live objects on the heap.  This could be used for various debugging purposes; currently the only use is to print the objects that are still alive at the end of a run when the environment variable :envvar:`PYTHONDUMPREFS` is set."
msgstr ""

#: ../../c-api/typeobj.rst:502
#: ../../c-api/typeobj.rst:515
#: ../../c-api/typeobj.rst:538
#: ../../c-api/typeobj.rst:551
#: ../../c-api/typeobj.rst:593
#: ../../c-api/typeobj.rst:636
#: ../../c-api/typeobj.rst:667
#: ../../c-api/typeobj.rst:723
#: ../../c-api/typeobj.rst:742
#: ../../c-api/typeobj.rst:759
#: ../../c-api/typeobj.rst:777
#: ../../c-api/typeobj.rst:801
#: ../../c-api/typeobj.rst:818
#: ../../c-api/typeobj.rst:830
#: ../../c-api/typeobj.rst:842
#: ../../c-api/typeobj.rst:875
#: ../../c-api/typeobj.rst:893
#: ../../c-api/typeobj.rst:913
#: ../../c-api/typeobj.rst:934
#: ../../c-api/typeobj.rst:960
#: ../../c-api/typeobj.rst:979
#: ../../c-api/typeobj.rst:995
#: ../../c-api/typeobj.rst:1031
#: ../../c-api/typeobj.rst:1042
#: ../../c-api/typeobj.rst:1052
#: ../../c-api/typeobj.rst:1062
#: ../../c-api/typeobj.rst:1076
#: ../../c-api/typeobj.rst:1095
#: ../../c-api/typeobj.rst:1118
#: ../../c-api/typeobj.rst:1163
#: ../../c-api/typeobj.rst:1187
#: ../../c-api/typeobj.rst:1229
#: ../../c-api/typeobj.rst:1290
#: ../../c-api/typeobj.rst:1355
#: ../../c-api/typeobj.rst:1385
#: ../../c-api/typeobj.rst:1417
#: ../../c-api/typeobj.rst:1440
#: ../../c-api/typeobj.rst:1453
#: ../../c-api/typeobj.rst:1468
#: ../../c-api/typeobj.rst:1482
#: ../../c-api/typeobj.rst:1512
#: ../../c-api/typeobj.rst:1532
#: ../../c-api/typeobj.rst:1558
#: ../../c-api/typeobj.rst:1576
#: ../../c-api/typeobj.rst:1616
#: ../../c-api/typeobj.rst:1667
#: ../../c-api/typeobj.rst:1684
#: ../../c-api/typeobj.rst:1722
#: ../../c-api/typeobj.rst:1743
#: ../../c-api/typeobj.rst:1775
#: ../../c-api/typeobj.rst:1792
#: ../../c-api/typeobj.rst:1803
#: ../../c-api/typeobj.rst:1813
#: ../../c-api/typeobj.rst:1822
#: ../../c-api/typeobj.rst:1832
#: ../../c-api/typeobj.rst:1846
#: ../../c-api/typeobj.rst:1884
msgid "**Inheritance:**"
msgstr ""

#: ../../c-api/typeobj.rst:504
msgid "These fields are not inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:509
msgid "This is the type object's reference count, initialized to ``1`` by the ``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type objects, the type's instances (objects whose :attr:`ob_type` points back to the type) do *not* count as references.  But for dynamically allocated type objects, the instances *do* count as references."
msgstr ""

#: ../../c-api/typeobj.rst:517
#: ../../c-api/typeobj.rst:553
#: ../../c-api/typeobj.rst:595
msgid "This field is not inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:522
msgid "This is the type's type, in other words its metatype.  It is initialized by the argument to the ``PyObject_HEAD_INIT`` macro, and its value should normally be ``&PyType_Type``.  However, for dynamically loadable extension modules that must be usable on Windows (at least), the compiler complains that this is not a valid initializer.  Therefore, the convention is to pass *NULL* to the ``PyObject_HEAD_INIT`` macro and to initialize this field explicitly at the start of the module's initialization function, before doing anything else.  This is typically done like this::"
msgstr ""

#: ../../c-api/typeobj.rst:533
msgid "This should be done before any instances of the type are created. :c:func:`PyType_Ready` checks if :attr:`ob_type` is *NULL*, and if so, initializes it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""

#: ../../c-api/typeobj.rst:540
#: ../../c-api/typeobj.rst:669
#: ../../c-api/typeobj.rst:803
#: ../../c-api/typeobj.rst:895
#: ../../c-api/typeobj.rst:915
#: ../../c-api/typeobj.rst:1419
#: ../../c-api/typeobj.rst:1442
#: ../../c-api/typeobj.rst:1560
#: ../../c-api/typeobj.rst:1578
#: ../../c-api/typeobj.rst:1669
#: ../../c-api/typeobj.rst:1777
#: ../../c-api/typeobj.rst:1886
msgid "This field is inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:544
msgid "PyVarObject Slots"
msgstr ""

#: ../../c-api/typeobj.rst:548
msgid "For statically allocated type objects, this should be initialized to zero.  For dynamically allocated type objects, this field has a special internal meaning."
msgstr ""

#: ../../c-api/typeobj.rst:557
msgid "PyTypeObject Slots"
msgstr ""

#: ../../c-api/typeobj.rst:559
msgid "Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` may set a value when the field is set to *NULL* then there will also be a \"Default\" section.  (Note that many fields set on :c:type:`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""

#: ../../c-api/typeobj.rst:566
msgid "Pointer to a NUL-terminated string containing the name of the type. For types that are accessible as module globals, the string should be the full module name, followed by a dot, followed by the type name; for built-in types, it should be just the type name.  If the module is a submodule of a package, the full package name is part of the full module name.  For example, a type named :class:`T` defined in module :mod:`M` in subpackage :mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject.tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""

#: ../../c-api/typeobj.rst:574
msgid "For dynamically allocated type objects, this should just be the type name, and the module name explicitly stored in the type dict as the value for key ``'__module__'``."
msgstr ""

#: ../../c-api/typeobj.rst:578
msgid "For statically allocated type objects, the tp_name field should contain a dot. Everything before the last dot is made accessible as the :attr:`__module__` attribute, and everything after the last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""

#: ../../c-api/typeobj.rst:583
msgid "If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is made accessible as the :attr:`~definition.__name__` attribute, and the :attr:`__module__` attribute is undefined (unless explicitly set in the dictionary, as explained above).  This means your type will be impossible to pickle.  Additionally, it will not be listed in module documentations created with pydoc."
msgstr ""

#: ../../c-api/typeobj.rst:589
msgid "This field must not be *NULL*.  It is the only required field in :c:func:`PyTypeObject` (other than potentially :c:member:`~PyTypeObject.tp_itemsize`)."
msgstr ""

#: ../../c-api/typeobj.rst:601
msgid "These fields allow calculating the size in bytes of instances of the type."
msgstr ""

#: ../../c-api/typeobj.rst:603
msgid "There are two kinds of types: types with fixed-length instances have a zero :c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For a type with fixed-length instances, all instances have the same size, given in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""

#: ../../c-api/typeobj.rst:608
msgid "For a type with variable-length instances, the instances must have an :attr:`ob_size` field, and the instance size is :c:member:`~PyTypeObject.tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is the \"length\" of the object.  The value of N is typically stored in the instance's :attr:`ob_size` field.  There are exceptions:  for example, ints use a negative :attr:`ob_size` to indicate a negative number, and N is ``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in the instance layout doesn't mean that the instance structure is variable-length (for example, the structure for the list type has fixed-length instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""

#: ../../c-api/typeobj.rst:619
msgid "The basic size includes the fields in the instance declared by the macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to declare the instance struct) and this in turn includes the :attr:`_ob_prev` and :attr:`_ob_next` fields if they are present.  This means that the only correct way to get an initializer for the :c:member:`~PyTypeObject.tp_basicsize` is to use the ``sizeof`` operator on the struct used to declare the instance layout. The basic size does not include the GC header size."
msgstr ""

#: ../../c-api/typeobj.rst:627
msgid "A note about alignment: if the variable items require a particular alignment, this should be taken care of by the value of :c:member:`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. It is the programmer's responsibility that :c:member:`~PyTypeObject.tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the alignment requirement for ``double``)."
msgstr ""

#: ../../c-api/typeobj.rst:634
msgid "For any type with variable-length instances, this field must not be *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:638
msgid "These fields are inherited separately by subtypes.  If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a subtype (though this depends on the implementation of the base type)."
msgstr ""

#: ../../c-api/typeobj.rst:646
msgid "A pointer to the instance destructor function.  This function must be defined unless the type guarantees that its instances will never be deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  The function signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:652
msgid "The destructor function is called by the :c:func:`Py_DECREF` and :c:func:`Py_XDECREF` macros when the new reference count is zero.  At this point, the instance is still in existence, but there are no references to it.  The destructor function should free all references which the instance owns, free all memory buffers owned by the instance (using the freeing function corresponding to the allocation function used to allocate the buffer), and finally (as its last action) call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), it is permissible to call the object deallocator directly instead of via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the one used to allocate the instance; this is normally :c:func:`PyObject_Del` if the instance was allocated using :c:func:`PyObject_New` or :c:func:`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""

#: ../../c-api/typeobj.rst:674
msgid "An optional offset to a per-instance function that implements calling the object using the *vectorcall* protocol, a more efficient alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:678
msgid "This field is only used if the flag :const:`_Py_TPFLAGS_HAVE_VECTORCALL` is set. If so, this must be a positive integer containing the offset in the instance of a :c:type:`vectorcallfunc` pointer. The signature is the same as for :c:func:`_PyObject_Vectorcall`::"
msgstr ""

#: ../../c-api/typeobj.rst:685
msgid "The *vectorcallfunc* pointer may be zero, in which case the instance behaves as if :const:`_Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""

#: ../../c-api/typeobj.rst:689
msgid "Any class that sets ``_Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the *vectorcallfunc* function. This can be done by setting *tp_call* to ``PyVectorcall_Call``:"
msgstr ""

#: ../../c-api/typeobj.rst:696
msgid "Call *callable*'s *vectorcallfunc* with positional and keyword arguments given in a tuple and dict, respectively."
msgstr ""

#: ../../c-api/typeobj.rst:699
msgid "This function is intended to be used in the ``tp_call`` slot. It does not fall back to ``tp_call`` and it currently does not check the ``_Py_TPFLAGS_HAVE_VECTORCALL`` flag. To call an object, use one of the :c:func:`PyObject_Call <PyObject_Call>` functions instead."
msgstr ""

#: ../../c-api/typeobj.rst:707
msgid "It is not recommended for :ref:`heap types <heap-types>` to implement the vectorcall protocol. When a user sets ``__call__`` in Python code, only ``tp_call`` is updated, possibly making it inconsistent with the vectorcall function."
msgstr ""

#: ../../c-api/typeobj.rst:714
msgid "The semantics of the ``tp_vectorcall_offset`` slot are provisional and expected to be finalized in Python 3.9. If you use vectorcall, plan for updating your code for Python 3.9."
msgstr ""

#: ../../c-api/typeobj.rst:720
msgid "This slot was used for print formatting in Python 2.x. In Python 3.0 to 3.7, it was reserved and named ``tp_print``."
msgstr ""

#: ../../c-api/typeobj.rst:725
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_call`: a subtype inherits :c:member:`~PyTypeObject.tp_vectorcall_offset` from its base type when the subtype’s :c:member:`~PyTypeObject.tp_call` is NULL."
msgstr ""

#: ../../c-api/typeobj.rst:730
msgid "Note that `heap types`_ (including subclasses defined in Python) do not inherit the :const:`_Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""

#: ../../c-api/typeobj.rst:736
msgid "An optional pointer to the get-attribute-string function."
msgstr ""

#: ../../c-api/typeobj.rst:738
msgid "This field is deprecated.  When it is defined, it should point to a function that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, but taking a C string instead of a Python string object to give the attribute name."
msgstr ""

#: ../../c-api/typeobj.rst:744
#: ../../c-api/typeobj.rst:936
msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr ""

#: ../../c-api/typeobj.rst:746
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:753
#: ../../c-api/typeobj.rst:949
msgid "An optional pointer to the function for setting and deleting attributes."
msgstr ""

#: ../../c-api/typeobj.rst:755
msgid "This field is deprecated.  When it is defined, it should point to a function that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, but taking a C string instead of a Python string object to give the attribute name."
msgstr ""

#: ../../c-api/typeobj.rst:761
#: ../../c-api/typeobj.rst:962
msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr ""

#: ../../c-api/typeobj.rst:763
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:770
msgid "Pointer to an additional structure that contains fields relevant only to objects which implement :term:`awaitable` and :term:`asynchronous iterator` protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""

#: ../../c-api/typeobj.rst:774
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr ""

#: ../../c-api/typeobj.rst:779
msgid "The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:787
msgid "An optional pointer to a function that implements the built-in function :func:`repr`."
msgstr ""

#: ../../c-api/typeobj.rst:790
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr ""

#: ../../c-api/typeobj.rst:794
msgid "The function must return a string or a Unicode object.  Ideally, this function should return a string that, when passed to :func:`eval`, given a suitable environment, returns an object with the same value.  If this is not feasible, it should return a string starting with ``'<'`` and ending with ``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""

#: ../../c-api/typeobj.rst:805
#: ../../c-api/typeobj.rst:917
#: ../../c-api/typeobj.rst:942
#: ../../c-api/typeobj.rst:968
#: ../../c-api/typeobj.rst:1010
#: ../../c-api/typeobj.rst:1364
#: ../../c-api/typeobj.rst:1516
#: ../../c-api/typeobj.rst:1537
#: ../../c-api/typeobj.rst:1635
#: ../../c-api/typeobj.rst:1671
#: ../../c-api/typeobj.rst:1689
#: ../../c-api/typeobj.rst:1727
#: ../../c-api/typeobj.rst:1748
#: ../../c-api/typeobj.rst:1779
msgid "**Default:**"
msgstr ""

#: ../../c-api/typeobj.rst:807
msgid "When this field is not set, a string of the form ``<%s object at %p>`` is returned, where ``%s`` is replaced by the type name, and ``%p`` by the object's memory address."
msgstr ""

#: ../../c-api/typeobj.rst:814
msgid "Pointer to an additional structure that contains fields relevant only to objects which implement the number protocol.  These fields are documented in :ref:`number-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:820
msgid "The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:826
msgid "Pointer to an additional structure that contains fields relevant only to objects which implement the sequence protocol.  These fields are documented in :ref:`sequence-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:832
msgid "The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:838
msgid "Pointer to an additional structure that contains fields relevant only to objects which implement the mapping protocol.  These fields are documented in :ref:`mapping-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:844
msgid "The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:852
msgid "An optional pointer to a function that implements the built-in function :func:`hash`."
msgstr ""

#: ../../c-api/typeobj.rst:855
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr ""

#: ../../c-api/typeobj.rst:859
msgid "The value ``-1`` should not be returned as a normal return value; when an error occurs during the computation of the hash value, the function should set an exception and return ``-1``."
msgstr ""

#: ../../c-api/typeobj.rst:863
msgid "When this field is not set (*and* :attr:`tp_richcompare` is not set), an attempt to take the hash of the object raises :exc:`TypeError`. This is the same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""

#: ../../c-api/typeobj.rst:867
msgid "This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to block inheritance of the hash method from a parent type. This is interpreted as the equivalent of ``__hash__ = None`` at the Python level, causing ``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note that the converse is also true - setting ``__hash__ = None`` on a class at the Python level will result in the ``tp_hash`` slot being set to :c:func:`PyObject_HashNotImplemented`."
msgstr ""

#: ../../c-api/typeobj.rst:877
#: ../../c-api/typeobj.rst:1357
msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr ""

#: ../../c-api/typeobj.rst:879
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:887
msgid "An optional pointer to a function that implements calling the object.  This should be *NULL* if the object is not callable.  The signature is the same as for :c:func:`PyObject_Call`::"
msgstr ""

#: ../../c-api/typeobj.rst:900
msgid "An optional pointer to a function that implements the built-in operation :func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls the constructor for that type.  This constructor calls :c:func:`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call this handler.)"
msgstr ""

#: ../../c-api/typeobj.rst:905
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr ""

#: ../../c-api/typeobj.rst:909
msgid "The function must return a string or a Unicode object.  It should be a \"friendly\" string representation of the object, as this is the representation that will be used, among other things, by the :func:`print` function."
msgstr ""

#: ../../c-api/typeobj.rst:919
msgid "When this field is not set, :c:func:`PyObject_Repr` is called to return a string representation."
msgstr ""

#: ../../c-api/typeobj.rst:925
msgid "An optional pointer to the get-attribute function."
msgstr ""

#: ../../c-api/typeobj.rst:927
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:931
msgid "It is usually convenient to set this field to :c:func:`PyObject_GenericGetAttr`, which implements the normal way of looking for object attributes."
msgstr ""

#: ../../c-api/typeobj.rst:938
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` from its base type when the subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:944
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:951
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr ""

#: ../../c-api/typeobj.rst:955
msgid "In addition, setting *value* to *NULL* to delete an attribute must be supported.  It is usually convenient to set this field to :c:func:`PyObject_GenericSetAttr`, which implements the normal way of setting object attributes."
msgstr ""

#: ../../c-api/typeobj.rst:964
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` from its base type when the subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:970
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:975
msgid "Pointer to an additional structure that contains fields relevant only to objects which implement the buffer interface.  These fields are documented in :ref:`buffer-structs`."
msgstr ""

#: ../../c-api/typeobj.rst:981
msgid "The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the contained fields are inherited individually."
msgstr ""

#: ../../c-api/typeobj.rst:987
msgid "This field is a bit mask of various flags.  Some flags indicate variant semantics for certain situations; others are used to indicate that certain fields in the type object (or in the extension structures referenced via :c:member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:`~PyTypeObject.tp_as_buffer`) that were historically not always present are valid; if such a flag bit is clear, the type fields it guards must not be accessed and must be considered to have a zero or *NULL* value instead."
msgstr ""

#: ../../c-api/typeobj.rst:997
msgid "Inheritance of this field is complicated.  Most flag bits are inherited individually, i.e. if the base type has a flag bit set, the subtype inherits this flag bit.  The flag bits that pertain to extension structures are strictly inherited if the extension structure is inherited, i.e. the base type's value of the flag bit is copied into the subtype together with a pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have *NULL* values."
msgstr ""

#: ../../c-api/typeobj.rst:1012
msgid ":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE``."
msgstr ""

#: ../../c-api/typeobj.rst:1015
msgid "**Bit Masks:**"
msgstr ""

#: ../../c-api/typeobj.rst:1017
msgid "The following bit masks are currently defined; these can be ORed together using the ``|`` operator to form the value of the :c:member:`~PyTypeObject.tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""

#: ../../c-api/typeobj.rst:1024
msgid "This bit is set when the type object itself is allocated on the heap.  In this case, the :attr:`ob_type` field of its instances is considered a reference to the type, and the type object is INCREF'ed when a new instance is created, and DECREF'ed when an instance is destroyed (this does not apply to instances of subtypes; only the type referenced by the instance's ob_type gets INCREF'ed or DECREF'ed)."
msgstr ""

#: ../../c-api/typeobj.rst:1033
#: ../../c-api/typeobj.rst:1044
#: ../../c-api/typeobj.rst:1054
#: ../../c-api/typeobj.rst:1064
#: ../../c-api/typeobj.rst:1097
msgid "???"
msgstr ""

#: ../../c-api/typeobj.rst:1038
msgid "This bit is set when the type can be used as the base type of another type.  If this bit is clear, the type cannot be subtyped (similar to a \"final\" class in Java)."
msgstr ""

#: ../../c-api/typeobj.rst:1049
msgid "This bit is set when the type object has been fully initialized by :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1059
msgid "This bit is set while :c:func:`PyType_Ready` is in the process of initializing the type object."
msgstr ""

#: ../../c-api/typeobj.rst:1069
msgid "This bit is set when the object supports garbage collection.  If this bit is set, instances must be created using :c:func:`PyObject_GC_New` and destroyed using :c:func:`PyObject_GC_Del`.  More information in section :ref:`supporting-cycle-detection`.  This bit also implies that the GC-related fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` are present in the type object."
msgstr ""

#: ../../c-api/typeobj.rst:1078
#: ../../c-api/typeobj.rst:1231
#: ../../c-api/typeobj.rst:1292
msgid "Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""

#: ../../c-api/typeobj.rst:1080
msgid "The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have *NULL* values."
msgstr ""

#: ../../c-api/typeobj.rst:1090
msgid "This is a bitmask of all the bits that pertain to the existence of certain fields in the type object and its extension structures. Currently, it includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`, :const:`Py_TPFLAGS_HAVE_VERSION_TAG`."
msgstr ""

#: ../../c-api/typeobj.rst:1102
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""

#: ../../c-api/typeobj.rst:1104
msgid "If this flag is set for ``type(meth)``, then:"
msgstr ""

#: ../../c-api/typeobj.rst:1106
msgid "``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1109
msgid "``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to ``meth(*args, **kwds)``."
msgstr ""

#: ../../c-api/typeobj.rst:1112
msgid "This flag enables an optimization for typical method calls like ``obj.meth()``: it avoids creating a temporary \"bound method\" object for ``obj.meth``."
msgstr ""

#: ../../c-api/typeobj.rst:1120
msgid "This flag is never inherited by heap types. For extension types, it is inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1137
msgid "These flags are used by functions such as :c:func:`PyLong_Check` to quickly determine if a type is a subclass of a built-in type; such specific checks are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom types that inherit from built-ins should have their :c:member:`~PyTypeObject.tp_flags` set appropriately, or the code that interacts with such types will behave differently depending on what kind of check is used."
msgstr ""

#: ../../c-api/typeobj.rst:1148
msgid "This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is present in the type structure."
msgstr ""

#: ../../c-api/typeobj.rst:1153
msgid "This flag isn't necessary anymore, as the interpreter assumes the :c:member:`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""

#: ../../c-api/typeobj.rst:1160
msgid "This bit is set when the class implements the vectorcall protocol. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for details."
msgstr ""

#: ../../c-api/typeobj.rst:1165
msgid "This bit is set on *static* subtypes if ``tp_flags`` is not overridden: a subtype inherits ``_Py_TPFLAGS_HAVE_VECTORCALL`` from its base type when the subtype’s :c:member:`~PyTypeObject.tp_call` is NULL and the subtype's ``Py_TPFLAGS_HEAPTYPE`` is not set."
msgstr ""

#: ../../c-api/typeobj.rst:1170
msgid "`Heap types`_ do not inherit ``_Py_TPFLAGS_HAVE_VECTORCALL``."
msgstr ""

#: ../../c-api/typeobj.rst:1174
msgid "This flag is provisional and expected to become public in Python 3.9, with a different name and, possibly, changed semantics. If you use vectorcall, plan for updating your code for Python 3.9."
msgstr ""

#: ../../c-api/typeobj.rst:1183
msgid "An optional pointer to a NUL-terminated C string giving the docstring for this type object.  This is exposed as the :attr:`__doc__` attribute on the type and instances of the type."
msgstr ""

#: ../../c-api/typeobj.rst:1189
msgid "This field is *not* inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:1194
msgid "An optional pointer to a traversal function for the garbage collector.  This is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1199
#: ../../c-api/typeobj.rst:1287
msgid "More information about Python's garbage collection scheme can be found in section :ref:`supporting-cycle-detection`."
msgstr ""

#: ../../c-api/typeobj.rst:1202
msgid "The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage collector to detect reference cycles. A typical implementation of a :c:member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` on each of the instance's members that are Python objects.  For example, this is function :c:func:`local_traverse` from the :mod:`_thread` extension module::"
msgstr ""

#: ../../c-api/typeobj.rst:1217
msgid "Note that :c:func:`Py_VISIT` is called only on those members that can participate in reference cycles.  Although there is also a ``self->key`` member, it can only be *NULL* or a Python string and therefore cannot be part of a reference cycle."
msgstr ""

#: ../../c-api/typeobj.rst:1221
msgid "On the other hand, even if you know a member can never be part of a cycle, as a debugging aid you may want to visit it anyway just so the :mod:`gc` module's :func:`~gc.get_referents` function will include it."
msgstr ""

#: ../../c-api/typeobj.rst:1225
msgid "Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:func:`local_traverse` to have these specific names; don't name them just anything."
msgstr ""

#: ../../c-api/typeobj.rst:1233
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if they are all zero in the subtype."
msgstr ""

#: ../../c-api/typeobj.rst:1241
msgid "An optional pointer to a clear function for the garbage collector. This is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1246
msgid "The :c:member:`~PyTypeObject.tp_clear` member function is used to break reference cycles in cyclic garbage detected by the garbage collector.  Taken together, all :c:member:`~PyTypeObject.tp_clear` functions in the system must combine to break all reference cycles.  This is subtle, and if in any doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` function, because it's possible to prove that no reference cycle can be composed entirely of tuples. Therefore the :c:member:`~PyTypeObject.tp_clear` functions of other types must be sufficient to break any cycle containing a tuple.  This isn't immediately obvious, and there's rarely a good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1256
msgid "Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the instance's references to those of its members that may be Python objects, and set its pointers to those members to *NULL*, as in the following example::"
msgstr ""

#: ../../c-api/typeobj.rst:1270
msgid "The :c:func:`Py_CLEAR` macro should be used, because clearing references is delicate:  the reference to the contained object must not be decremented until after the pointer to the contained object is set to *NULL*.  This is because decrementing the reference count may cause the contained object to become trash, triggering a chain of reclamation activity that may include invoking arbitrary Python code (due to finalizers, or weakref callbacks, associated with the contained object). If it's possible for such code to reference *self* again, it's important that the pointer to the contained object be *NULL* at that time, so that *self* knows the contained object can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations in a safe order."
msgstr ""

#: ../../c-api/typeobj.rst:1281
msgid "Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break reference cycles, it's not necessary to clear contained objects like Python strings or Python integers, which can't participate in reference cycles. On the other hand, it may be convenient to clear all contained Python objects, and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""

#: ../../c-api/typeobj.rst:1294
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if they are all zero in the subtype."
msgstr ""

#: ../../c-api/typeobj.rst:1302
msgid "An optional pointer to the rich comparison function, whose signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1306
msgid "The first parameter is guaranteed to be an instance of the type that is defined by :c:type:`PyTypeObject`."
msgstr ""

#: ../../c-api/typeobj.rst:1309
msgid "The function should return the result of the comparison (usually ``Py_True`` or ``Py_False``).  If the comparison is undefined, it must return ``Py_NotImplemented``, if another error occurred it must return *NULL* and set an exception condition."
msgstr ""

#: ../../c-api/typeobj.rst:1316
msgid "If you want to implement a type for which only a limited set of comparisons makes sense (e.g. ``==`` and ``!=``, but not ``<`` and friends), directly raise :exc:`TypeError` in the rich comparison function."
msgstr ""

#: ../../c-api/typeobj.rst:1320
msgid "The following constants are defined to be used as the third argument for :c:member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""

#: ../../c-api/typeobj.rst:1324
msgid "Constant"
msgstr ""

#: ../../c-api/typeobj.rst:1324
msgid "Comparison"
msgstr ""

#: ../../c-api/typeobj.rst:1326
msgid ":const:`Py_LT`"
msgstr ""

#: ../../c-api/typeobj.rst:1326
msgid "``<``"
msgstr ""

#: ../../c-api/typeobj.rst:1328
msgid ":const:`Py_LE`"
msgstr ""

#: ../../c-api/typeobj.rst:1328
msgid "``<=``"
msgstr ""

#: ../../c-api/typeobj.rst:1330
msgid ":const:`Py_EQ`"
msgstr ""

#: ../../c-api/typeobj.rst:1330
msgid "``==``"
msgstr ""

#: ../../c-api/typeobj.rst:1332
msgid ":const:`Py_NE`"
msgstr ""

#: ../../c-api/typeobj.rst:1332
msgid "``!=``"
msgstr ""

#: ../../c-api/typeobj.rst:1334
msgid ":const:`Py_GT`"
msgstr ""

#: ../../c-api/typeobj.rst:1334
msgid "``>``"
msgstr ""

#: ../../c-api/typeobj.rst:1336
msgid ":const:`Py_GE`"
msgstr ""

#: ../../c-api/typeobj.rst:1336
msgid "``>=``"
msgstr ""

#: ../../c-api/typeobj.rst:1339
msgid "The following macro is defined to ease writing rich comparison functions:"
msgstr ""

#: ../../c-api/typeobj.rst:1343
msgid "Return ``Py_True`` or ``Py_False`` from the function, depending on the result of a comparison. VAL_A and VAL_B must be orderable by C comparison operators (for example, they may be C ints or floats). The third argument specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""

#: ../../c-api/typeobj.rst:1349
msgid "The return value's reference count is properly incremented."
msgstr ""

#: ../../c-api/typeobj.rst:1351
msgid "On error, sets an exception and returns *NULL* from the function."
msgstr ""

#: ../../c-api/typeobj.rst:1359
msgid "This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:1366
msgid ":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` implementation, which may be inherited.  However, if only :attr:`tp_hash` is defined, not even the inherited function is used and instances of the type will not be able to participate in any comparisons."
msgstr ""

#: ../../c-api/typeobj.rst:1375
msgid "If the instances of this type are weakly referenceable, this field is greater than zero and contains the offset in the instance structure of the weak reference list head (ignoring the GC header, if present); this offset is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` functions.  The instance structure needs to include a field of type :c:type:`PyObject\\*` which is initialized to *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:1382
msgid "Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that is the list head for weak references to the type object itself."
msgstr ""

#: ../../c-api/typeobj.rst:1387
msgid "This field is inherited by subtypes, but see the rules listed below. A subtype may override this offset; this means that the subtype uses a different weak reference list head than the base type.  Since the list head is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should not be a problem."
msgstr ""

#: ../../c-api/typeobj.rst:1392
msgid "When a type defined by a class statement has no :attr:`~object.__slots__` declaration, and none of its base types are weakly referenceable, the type is made weakly referenceable by adding a weak reference list head slot to the instance layout and setting the :c:member:`~PyTypeObject.tp_weaklistoffset` of that slot's offset."
msgstr ""

#: ../../c-api/typeobj.rst:1397
msgid "When a type's :attr:`__slots__` declaration contains a slot named :attr:`__weakref__`, that slot becomes the weak reference list head for instances of the type, and the slot's offset is stored in the type's :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""

#: ../../c-api/typeobj.rst:1402
msgid "When a type's :attr:`__slots__` declaration does not contain a slot named :attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject.tp_weaklistoffset` from its base type."
msgstr ""

#: ../../c-api/typeobj.rst:1409
msgid "An optional pointer to a function that returns an iterator for the object.  Its presence normally signals that the instances of this type are iterable (although sequences may be iterable without this function)."
msgstr ""

#: ../../c-api/typeobj.rst:1413
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr ""

#: ../../c-api/typeobj.rst:1424
msgid "An optional pointer to a function that returns the next item in an iterator. The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1429
msgid "When the iterator is exhausted, it must return *NULL*; a :exc:`StopIteration` exception may or may not be set.  When another error occurs, it must return *NULL* too.  Its presence signals that the instances of this type are iterators."
msgstr ""

#: ../../c-api/typeobj.rst:1434
msgid "Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` function, and that function should return the iterator instance itself (not a new iterator instance)."
msgstr ""

#: ../../c-api/typeobj.rst:1438
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr ""

#: ../../c-api/typeobj.rst:1447
msgid "An optional pointer to a static *NULL*-terminated array of :c:type:`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1450
msgid "For each entry in the array, an entry is added to the type's dictionary (see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1455
msgid "This field is not inherited by subtypes (methods are inherited through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1461
msgid "An optional pointer to a static *NULL*-terminated array of :c:type:`PyMemberDef` structures, declaring regular data members (fields or slots) of instances of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1465
msgid "For each entry in the array, an entry is added to the type's dictionary (see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1470
msgid "This field is not inherited by subtypes (members are inherited through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1476
msgid "An optional pointer to a static *NULL*-terminated array of :c:type:`PyGetSetDef` structures, declaring computed attributes of instances of this type."
msgstr ""

#: ../../c-api/typeobj.rst:1479
msgid "For each entry in the array, an entry is added to the type's dictionary (see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""

#: ../../c-api/typeobj.rst:1484
msgid "This field is not inherited by subtypes (computed attributes are inherited through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1490
msgid "An optional pointer to a base type from which type properties are inherited.  At this level, only single inheritance is supported; multiple inheritance require dynamically creating a type object by calling the metatype."
msgstr ""

#: ../../c-api/typeobj.rst:1498
msgid "Slot initialization is subject to the rules of initializing globals. C99 requires the initializers to be \"address constants\".  Function designators like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are valid C99 address constants."
msgstr ""

#: ../../c-api/typeobj.rst:1503
msgid "However, the unary '&' operator applied to a non-static variable like :c:func:`PyBaseObject_Type` is not required to produce an address constant.  Compilers may support this (gcc does), MSVC does not. Both compilers are strictly standard conforming in this particular behavior."
msgstr ""

#: ../../c-api/typeobj.rst:1509
msgid "Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the extension module's init function."
msgstr ""

#: ../../c-api/typeobj.rst:1514
msgid "This field is not inherited by subtypes (obviously)."
msgstr ""

#: ../../c-api/typeobj.rst:1518
msgid "This field defaults to ``&PyBaseObject_Type`` (which to Python programmers is known as the type :class:`object`)."
msgstr ""

#: ../../c-api/typeobj.rst:1524
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1526
msgid "This field should normally be initialized to *NULL* before PyType_Ready is called; it may also be initialized to a dictionary containing initial attributes for the type.  Once :c:func:`PyType_Ready` has initialized the type, extra attributes for the type may be added to this dictionary only if they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""

#: ../../c-api/typeobj.rst:1534
msgid "This field is not inherited by subtypes (though the attributes defined in here are inherited through a different mechanism)."
msgstr ""

#: ../../c-api/typeobj.rst:1539
msgid "If this field is *NULL*, :c:func:`PyType_Ready` will assign a new dictionary to it."
msgstr ""

#: ../../c-api/typeobj.rst:1544
msgid "It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""

#: ../../c-api/typeobj.rst:1550
msgid "An optional pointer to a \"descriptor get\" function."
msgstr ""

#: ../../c-api/typeobj.rst:1552
#: ../../c-api/typeobj.rst:1568
#: ../../c-api/typeobj.rst:1650
#: ../../c-api/typeobj.rst:1680
#: ../../c-api/typeobj.rst:1704
msgid "The function signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1565
msgid "An optional pointer to a function for setting and deleting a descriptor's value."
msgstr ""

#: ../../c-api/typeobj.rst:1572
msgid "The *value* argument is set to *NULL* to delete the value."
msgstr ""

#: ../../c-api/typeobj.rst:1583
msgid "If the instances of this type have a dictionary containing instance variables, this field is non-zero and contains the offset in the instances of the type of the instance variable dictionary; this offset is used by :c:func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../c-api/typeobj.rst:1588
msgid "Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is the dictionary for attributes of the type object itself."
msgstr ""

#: ../../c-api/typeobj.rst:1591
msgid "If the value of this field is greater than zero, it specifies the offset from the start of the instance structure.  If the value is less than zero, it specifies the offset from the *end* of the instance structure.  A negative offset is more expensive to use, and should only be used when the instance structure contains a variable-length part.  This is used for example to add an instance variable dictionary to subtypes of :class:`str` or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` field should account for the dictionary added to the end in that case, even though the dictionary is not included in the basic object layout.  On a system with a pointer size of 4 bytes, :c:member:`~PyTypeObject.tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at the very end of the structure."
msgstr ""

#: ../../c-api/typeobj.rst:1603
msgid "The real dictionary offset in an instance can be computed from a negative :c:member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""

#: ../../c-api/typeobj.rst:1610
msgid "where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject.tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the type object, and :attr:`ob_size` is taken from the instance.  The absolute value is taken because ints use the sign of :attr:`ob_size` to store the sign of the number.  (There's never a need to do this calculation yourself; it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""

#: ../../c-api/typeobj.rst:1618
msgid "This field is inherited by subtypes, but see the rules listed below. A subtype may override this offset; this means that the subtype instances store the dictionary at a difference offset than the base type.  Since the dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this should not be a problem."
msgstr ""

#: ../../c-api/typeobj.rst:1623
msgid "When a type defined by a class statement has no :attr:`~object.__slots__` declaration, and none of its base types has an instance variable dictionary, a dictionary slot is added to the instance layout and the :c:member:`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""

#: ../../c-api/typeobj.rst:1628
msgid "When a type defined by a class statement has a :attr:`__slots__` declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` from its base type."
msgstr ""

#: ../../c-api/typeobj.rst:1631
msgid "(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` declaration does not have the expected effect, it just causes confusion.  Maybe this should be added as a feature just like :attr:`__weakref__` though.)"
msgstr ""

#: ../../c-api/typeobj.rst:1637
msgid "This slot has no default.  For static types, if the field is *NULL* then no :attr:`__dict__` gets created for instances."
msgstr ""

#: ../../c-api/typeobj.rst:1643
msgid "An optional pointer to an instance initialization function."
msgstr ""

#: ../../c-api/typeobj.rst:1645
msgid "This function corresponds to the :meth:`__init__` method of classes.  Like :meth:`__init__`, it is possible to create an instance without calling :meth:`__init__`, and it is possible to reinitialize an instance by calling its :meth:`__init__` method again."
msgstr ""

#: ../../c-api/typeobj.rst:1654
msgid "The self argument is the instance to be initialized; the *args* and *kwds* arguments represent positional and keyword arguments of the call to :meth:`__init__`."
msgstr ""

#: ../../c-api/typeobj.rst:1658
msgid "The :c:member:`~PyTypeObject.tp_init` function, if not *NULL*, is called when an instance is created normally by calling its type, after the type's :c:member:`~PyTypeObject.tp_new` function has returned an instance of the type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance of some other type that is not a subtype of the original type, no :c:member:`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject.tp_new` returns an instance of a subtype of the original type, the subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""

#: ../../c-api/typeobj.rst:1665
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""

#: ../../c-api/typeobj.rst:1673
msgid "For static types this field does not have a default."
msgstr ""

#: ../../c-api/typeobj.rst:1678
msgid "An optional pointer to an instance allocation function."
msgstr ""

#: ../../c-api/typeobj.rst:1686
msgid "This field is inherited by static subtypes, but not by dynamic subtypes (subtypes created by a class statement)."
msgstr ""

#: ../../c-api/typeobj.rst:1691
msgid "For dynamic subtypes, this field is always set to :c:func:`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""

#: ../../c-api/typeobj.rst:1695
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:`PyType_GenericAlloc`.  That is the recommended value for all statically defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1702
msgid "An optional pointer to an instance creation function."
msgstr ""

#: ../../c-api/typeobj.rst:1708
msgid "The subtype argument is the type of the object being created; the *args* and *kwds* arguments represent positional and keyword arguments of the call to the type.  Note that subtype doesn't have to equal the type whose :c:member:`~PyTypeObject.tp_new` function is called; it may be a subtype of that type (but not an unrelated type)."
msgstr ""

#: ../../c-api/typeobj.rst:1714
msgid "The :c:member:`~PyTypeObject.tp_new` function should call ``subtype->tp_alloc(subtype, nitems)`` to allocate space for the object, and then do only as much further initialization as is absolutely necessary.  Initialization that can safely be ignored or repeated should be placed in the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that for immutable types, all initialization should take place in :c:member:`~PyTypeObject.tp_new`, while for mutable types, most initialization should be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""

#: ../../c-api/typeobj.rst:1724
msgid "This field is inherited by subtypes, except it is not inherited by static types whose :c:member:`~PyTypeObject.tp_base` is *NULL* or ``&PyBaseObject_Type``."
msgstr ""

#: ../../c-api/typeobj.rst:1729
msgid "For static types this field has no default.  This means if the slot is defined as *NULL*, the type cannot be called to create new instances; presumably there is some other way to create instances, like a factory function."
msgstr ""

#: ../../c-api/typeobj.rst:1737
msgid "An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1741
msgid "An initializer that is compatible with this signature is :c:func:`PyObject_Free`."
msgstr ""

#: ../../c-api/typeobj.rst:1745
msgid "This field is inherited by static subtypes, but not by dynamic subtypes (subtypes created by a class statement)"
msgstr ""

#: ../../c-api/typeobj.rst:1750
msgid "In dynamic subtypes, this field is set to a deallocator suitable to match :c:func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""

#: ../../c-api/typeobj.rst:1754
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr ""

#: ../../c-api/typeobj.rst:1759
msgid "An optional pointer to a function called by the garbage collector."
msgstr ""

#: ../../c-api/typeobj.rst:1761
msgid "The garbage collector needs to know whether a particular object is collectible or not.  Normally, it is sufficient to look at the object's type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically and dynamically allocated instances, and the statically allocated instances are not collectible.  Such types should define this function; it should return ``1`` for a collectible instance, and ``0`` for a non-collectible instance. The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1771
msgid "(The only example of this are types themselves.  The metatype, :c:data:`PyType_Type`, defines this function to distinguish between statically and dynamically allocated types.)"
msgstr ""

#: ../../c-api/typeobj.rst:1781
msgid "This slot has no default.  If this field is *NULL*, :const:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""

#: ../../c-api/typeobj.rst:1787
msgid "Tuple of base types."
msgstr ""

#: ../../c-api/typeobj.rst:1789
msgid "This is set for types created by a class statement.  It should be *NULL* for statically defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1794
#: ../../c-api/typeobj.rst:1815
#: ../../c-api/typeobj.rst:1824
#: ../../c-api/typeobj.rst:1834
#: ../../c-api/typeobj.rst:1848
msgid "This field is not inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1799
msgid "Tuple containing the expanded set of base types, starting with the type itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""

#: ../../c-api/typeobj.rst:1805
msgid "This field is not inherited; it is calculated fresh by :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1811
msgid "Unused.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:1820
msgid "List of weak references to subclasses.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:1829
msgid "Weak reference list head, for weak references to this type object.  Not inherited.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:1839
msgid "This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""

#: ../../c-api/typeobj.rst:1844
msgid "Used to index into the method cache.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:1853
msgid "An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1857
msgid "If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it once when finalizing an instance.  It is called either from the garbage collector (if the instance is part of an isolated reference cycle) or just before the object is deallocated.  Either way, it is guaranteed to be called before attempting to break reference cycles, ensuring that it finds the object in a sane state."
msgstr ""

#: ../../c-api/typeobj.rst:1864
msgid ":c:member:`~PyTypeObject.tp_finalize` should not mutate the current exception status; therefore, a recommended way to write a non-trivial finalizer is::"
msgstr ""

#: ../../c-api/typeobj.rst:1881
msgid "For this field to be taken into account (even through inheritance), you must also set the :const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit."
msgstr ""

#: ../../c-api/typeobj.rst:1890
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr ""

#: ../../c-api/typeobj.rst:1893
msgid "The remaining fields are only defined if the feature test macro :const:`COUNT_ALLOCS` is defined, and are for internal use only. They are documented here for completeness.  None of these fields are inherited by subtypes."
msgstr ""

#: ../../c-api/typeobj.rst:1900
msgid "Number of allocations."
msgstr ""

#: ../../c-api/typeobj.rst:1904
msgid "Number of frees."
msgstr ""

#: ../../c-api/typeobj.rst:1908
msgid "Maximum simultaneously allocated objects."
msgstr ""

#: ../../c-api/typeobj.rst:1912
msgid "Pointer to the previous type object with a non-zero :c:member:`~PyTypeObject.tp_allocs` field."
msgstr ""

#: ../../c-api/typeobj.rst:1916
msgid "Pointer to the next type object with a non-zero :c:member:`~PyTypeObject.tp_allocs` field."
msgstr ""

#: ../../c-api/typeobj.rst:1918
msgid "Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject.tp_dealloc` may be called from any Python thread, not just the thread which created the object (if the object becomes part of a refcount cycle, that cycle might be collected by a garbage collection on any thread).  This is not a problem for Python API calls, since the thread on which tp_dealloc is called will own the Global Interpreter Lock (GIL). However, if the object being destroyed in turn destroys objects from some other C or C++ library, care should be taken to ensure that destroying those objects on the thread which called tp_dealloc will not violate any assumptions of the library."
msgstr ""

#: ../../c-api/typeobj.rst:1932
msgid "Heap Types"
msgstr ""

#: ../../c-api/typeobj.rst:1934
msgid "Traditionally, types defined in C code are *static*, that is, a static :c:type:`PyTypeObject` structure is defined directly in code and initialized using :c:func:`PyType_Ready`."
msgstr ""

#: ../../c-api/typeobj.rst:1938
msgid "This results in types that are limited relative to types defined in Python:"
msgstr ""

#: ../../c-api/typeobj.rst:1940
msgid "Static types are limited to one base, i.e. they cannot use multiple inheritance."
msgstr ""

#: ../../c-api/typeobj.rst:1942
msgid "Static type objects (but not necessarily their instances) are immutable. It is not possible to add or modify the type object's attributes from Python."
msgstr ""

#: ../../c-api/typeobj.rst:1944
msgid "Static type objects are shared across :ref:`sub-interpreters <sub-interpreter-support>`, so they should not include any subinterpreter-specific state."
msgstr ""

#: ../../c-api/typeobj.rst:1948
msgid "Also, since *PyTypeObject* is not part of the :ref:`stable ABI <stable>`, any extension modules using static types must be compiled for a specific Python minor version."
msgstr ""

#: ../../c-api/typeobj.rst:1952
msgid "An alternative to static types is *heap-allocated types*, or *heap types* for short, which correspond closely to classes created by Python's ``class`` statement."
msgstr ""

#: ../../c-api/typeobj.rst:1956
msgid "This is done by filling a :c:type:`PyType_Spec` structure and calling :c:func:`PyType_FromSpecWithBases`."
msgstr ""

#: ../../c-api/typeobj.rst:1963
msgid "Number Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:1970
msgid "This structure holds pointers to the functions which an object uses to implement the number protocol.  Each function is used by the function of similar name documented in the :ref:`number` section."
msgstr ""

#: ../../c-api/typeobj.rst:1976
#: ../../c-api/typeobj.rst:2300
msgid "Here is the structure definition::"
msgstr ""

#: ../../c-api/typeobj.rst:2023
msgid "Binary and ternary functions must check the type of all their operands, and implement the necessary conversions (at least one of the operands is an instance of the defined type).  If the operation is not defined for the given operands, binary and ternary functions must return ``Py_NotImplemented``, if another error occurred they must return *NULL* and set an exception."
msgstr ""

#: ../../c-api/typeobj.rst:2032
msgid "The :c:data:`nb_reserved` field should always be *NULL*.  It was previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""

#: ../../c-api/typeobj.rst:2077
msgid "Mapping Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2084
msgid "This structure holds pointers to the functions which an object uses to implement the mapping protocol.  It has three members:"
msgstr ""

#: ../../c-api/typeobj.rst:2089
msgid "This function is used by :c:func:`PyMapping_Size` and :c:func:`PyObject_Size`, and has the same signature.  This slot may be set to *NULL* if the object has no defined length."
msgstr ""

#: ../../c-api/typeobj.rst:2095
msgid "This function is used by :c:func:`PyObject_GetItem` and :c:func:`PySequence_GetSlice`, and has the same signature as :c:func:`!PyObject_GetItem`.  This slot must be filled for the :c:func:`PyMapping_Check` function to return ``1``, it can be *NULL* otherwise."
msgstr ""

#: ../../c-api/typeobj.rst:2103
msgid "This function is used by :c:func:`PyObject_SetItem`, :c:func:`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:`PyObject_DelSlice`.  It has the same signature as :c:func:`!PyObject_SetItem`, but *v* can also be set to *NULL* to delete an item.  If this slot is *NULL*, the object does not support item assignment and deletion."
msgstr ""

#: ../../c-api/typeobj.rst:2114
msgid "Sequence Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2121
msgid "This structure holds pointers to the functions which an object uses to implement the sequence protocol."
msgstr ""

#: ../../c-api/typeobj.rst:2126
msgid "This function is used by :c:func:`PySequence_Size` and :c:func:`PyObject_Size`, and has the same signature.  It is also used for handling negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""

#: ../../c-api/typeobj.rst:2133
msgid "This function is used by :c:func:`PySequence_Concat` and has the same signature.  It is also used by the ``+`` operator, after trying the numeric addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2139
msgid "This function is used by :c:func:`PySequence_Repeat` and has the same signature.  It is also used by the ``*`` operator, after trying numeric multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2145
msgid "This function is used by :c:func:`PySequence_GetItem` and has the same signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This slot must be filled for the :c:func:`PySequence_Check` function to return ``1``, it can be *NULL* otherwise."
msgstr ""

#: ../../c-api/typeobj.rst:2151
msgid "Negative indexes are handled as follows: if the :attr:`sq_length` slot is filled, it is called and the sequence length is used to compute a positive index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is *NULL*, the index is passed as is to the function."
msgstr ""

#: ../../c-api/typeobj.rst:2158
msgid "This function is used by :c:func:`PySequence_SetItem` and has the same signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:`PyObject_DelItem`, after trying the item assignment and deletion via the :c:member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to *NULL* if the object does not support item assignment and deletion."
msgstr ""

#: ../../c-api/typeobj.rst:2167
msgid "This function may be used by :c:func:`PySequence_Contains` and has the same signature.  This slot may be left to *NULL*, in this case :c:func:`!PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""

#: ../../c-api/typeobj.rst:2174
msgid "This function is used by :c:func:`PySequence_InPlaceConcat` and has the same signature.  It should modify its first operand, and return it.  This slot may be left to *NULL*, in this case :c:func:`!PySequence_InPlaceConcat` will fall back to :c:func:`PySequence_Concat`.  It is also used by the augmented assignment ``+=``, after trying numeric in-place addition via the :c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2183
msgid "This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same signature.  It should modify its first operand, and return it.  This slot may be left to *NULL*, in this case :c:func:`!PySequence_InPlaceRepeat` will fall back to :c:func:`PySequence_Repeat`.  It is also used by the augmented assignment ``*=``, after trying numeric in-place multiplication via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""

#: ../../c-api/typeobj.rst:2194
msgid "Buffer Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2202
msgid "This structure holds pointers to the functions required by the :ref:`Buffer protocol <bufferobjects>`. The protocol defines how an exporter object can expose its internal data to consumer objects."
msgstr ""

#: ../../c-api/typeobj.rst:2208
#: ../../c-api/typeobj.rst:2257
#: ../../c-api/typeobj.rst:2310
#: ../../c-api/typeobj.rst:2321
#: ../../c-api/typeobj.rst:2332
msgid "The signature of this function is::"
msgstr ""

#: ../../c-api/typeobj.rst:2212
msgid "Handle a request to *exporter* to fill in *view* as specified by *flags*. Except for point (3), an implementation of this function MUST take these steps:"
msgstr ""

#: ../../c-api/typeobj.rst:2216
msgid "Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, set :c:data:`view->obj` to *NULL* and return ``-1``."
msgstr ""

#: ../../c-api/typeobj.rst:2219
msgid "Fill in the requested fields."
msgstr ""

#: ../../c-api/typeobj.rst:2221
msgid "Increment an internal counter for the number of exports."
msgstr ""

#: ../../c-api/typeobj.rst:2223
msgid "Set :c:data:`view->obj` to *exporter* and increment :c:data:`view->obj`."
msgstr ""

#: ../../c-api/typeobj.rst:2225
msgid "Return ``0``."
msgstr ""

#: ../../c-api/typeobj.rst:2227
msgid "If *exporter* is part of a chain or tree of buffer providers, two main schemes can be used:"
msgstr ""

#: ../../c-api/typeobj.rst:2230
msgid "Re-export: Each member of the tree acts as the exporting object and sets :c:data:`view->obj` to a new reference to itself."
msgstr ""

#: ../../c-api/typeobj.rst:2233
msgid "Redirect: The buffer request is redirected to the root object of the tree. Here, :c:data:`view->obj` will be a new reference to the root object."
msgstr ""

#: ../../c-api/typeobj.rst:2237
msgid "The individual fields of *view* are described in section :ref:`Buffer structure <buffer-structure>`, the rules how an exporter must react to specific requests are in section :ref:`Buffer request types <buffer-request-types>`."
msgstr ""

#: ../../c-api/typeobj.rst:2242
msgid "All memory pointed to in the :c:type:`Py_buffer` structure belongs to the exporter and must remain valid until there are no consumers left. :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer.internal` are read-only for the consumer."
msgstr ""

#: ../../c-api/typeobj.rst:2249
msgid ":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes buffer while dealing correctly with all request types."
msgstr ""

#: ../../c-api/typeobj.rst:2252
msgid ":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps this function."
msgstr ""

#: ../../c-api/typeobj.rst:2261
msgid "Handle a request to release the resources of the buffer. If no resources need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be *NULL*. Otherwise, a standard implementation of this function will take these optional steps:"
msgstr ""

#: ../../c-api/typeobj.rst:2266
msgid "Decrement an internal counter for the number of exports."
msgstr ""

#: ../../c-api/typeobj.rst:2268
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr ""

#: ../../c-api/typeobj.rst:2270
msgid "The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep track of buffer-specific resources. This field is guaranteed to remain constant, while a consumer MAY pass a copy of the original buffer as the *view* argument."
msgstr ""

#: ../../c-api/typeobj.rst:2276
msgid "This function MUST NOT decrement :c:data:`view->obj`, since that is done automatically in :c:func:`PyBuffer_Release` (this scheme is useful for breaking reference cycles)."
msgstr ""

#: ../../c-api/typeobj.rst:2281
msgid ":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this function."
msgstr ""

#: ../../c-api/typeobj.rst:2289
msgid "Async Object Structures"
msgstr ""

#: ../../c-api/typeobj.rst:2297
msgid "This structure holds pointers to the functions required to implement :term:`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""

#: ../../c-api/typeobj.rst:2314
msgid "The returned object must be an iterator, i.e. :c:func:`PyIter_Check` must return ``1`` for it."
msgstr ""

#: ../../c-api/typeobj.rst:2317
msgid "This slot may be set to *NULL* if an object is not an :term:`awaitable`."
msgstr ""

#: ../../c-api/typeobj.rst:2325
msgid "Must return an :term:`awaitable` object.  See :meth:`__anext__` for details."
msgstr ""

#: ../../c-api/typeobj.rst:2327
msgid "This slot may be set to *NULL* if an object does not implement asynchronous iteration protocol."
msgstr ""

#: ../../c-api/typeobj.rst:2336
msgid "Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. This slot may be set to *NULL*."
msgstr ""

#: ../../c-api/typeobj.rst:2343
msgid "Slot Type typedefs"
msgstr ""

#: ../../c-api/typeobj.rst:2347
msgid "The purpose of this function is to separate memory allocation from memory initialization.  It should return a pointer to a block of memory of adequate length for the instance, suitably aligned, and initialized to zeros, but with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's :attr:`ob_size` field should be initialized to *nitems* and the length of the allocated memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""

#: ../../c-api/typeobj.rst:2357
msgid "This function should not do any other instance initialization, not even to allocate additional memory; that should be done by :c:member:`~PyTypeObject.tp_new`."
msgstr ""

#: ../../c-api/typeobj.rst:2364
msgid "See :c:member:`~PyTypeObject.tp_vectorcall_offset`."
msgstr ""

#: ../../c-api/typeobj.rst:2366
msgid "Arguments to ``vectorcallfunc`` are the same as for :c:func:`_PyObject_Vectorcall`."
msgstr ""

#: ../../c-api/typeobj.rst:2372
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr ""

#: ../../c-api/typeobj.rst:2376
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr ""

#: ../../c-api/typeobj.rst:2380
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr ""

#: ../../c-api/typeobj.rst:2384
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr ""

#: ../../c-api/typeobj.rst:2388
#: ../../c-api/typeobj.rst:2397
msgid "Return the value of the named attribute for the object."
msgstr ""

#: ../../c-api/typeobj.rst:2392
#: ../../c-api/typeobj.rst:2403
msgid "Set the value of the named attribute for the object. The value argument is set to *NULL* to delete the attribute."
msgstr ""

#: ../../c-api/typeobj.rst:2399
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr ""

#: ../../c-api/typeobj.rst:2406
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr ""

#: ../../c-api/typeobj.rst:2410
msgid "See :c:member:`~PyTypeObject.tp_descrget`."
msgstr ""

#: ../../c-api/typeobj.rst:2414
msgid "See :c:member:`~PyTypeObject.tp_descrset`."
msgstr ""

#: ../../c-api/typeobj.rst:2418
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr ""

#: ../../c-api/typeobj.rst:2422
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr ""

#: ../../c-api/typeobj.rst:2426
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr ""

#: ../../c-api/typeobj.rst:2430
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr ""

#: ../../c-api/typeobj.rst:2456
msgid "Examples"
msgstr ""

#: ../../c-api/typeobj.rst:2458
msgid "The following are simple examples of Python type definitions.  They include common usage you may encounter.  Some demonstrate tricky corner cases.  For more examples, practical info, and a tutorial, see :ref:`defining-new-types` and :ref:`new-types-topics`."
msgstr ""

#: ../../c-api/typeobj.rst:2463
msgid "A basic static type::"
msgstr ""

#: ../../c-api/typeobj.rst:2480
msgid "You may also find older code (especially in the CPython code base) with a more verbose initializer::"
msgstr ""

#: ../../c-api/typeobj.rst:2524
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr ""

#: ../../c-api/typeobj.rst:2551
msgid "A str subclass that cannot be subclassed and cannot be called to create instances (e.g. uses a separate factory func)::"
msgstr ""

#: ../../c-api/typeobj.rst:2570
msgid "The simplest static type (with fixed-length instances)::"
msgstr ""

#: ../../c-api/typeobj.rst:2581
msgid "The simplest static type (with variable-length instances)::"
msgstr ""

