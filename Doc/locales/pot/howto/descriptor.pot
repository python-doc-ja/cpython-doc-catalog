# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-25 04:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr ""

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr ""

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr ""

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr ""

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr ""

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr ""

#: ../../howto/descriptor.rst:13
msgid ":term:`Descriptors <descriptor>` let objects customize attribute lookup, storage, and deletion."
msgstr ""

#: ../../howto/descriptor.rst:16
msgid "This HowTo guide has three major sections:"
msgstr ""

#: ../../howto/descriptor.rst:18
msgid "The \"primer\" gives a basic overview, moving gently from simple examples, adding one feature at a time.  It is a great place to start."
msgstr ""

#: ../../howto/descriptor.rst:21
msgid "The second section shows a complete, practical descriptor example.  If you already know the basics, start there."
msgstr ""

#: ../../howto/descriptor.rst:24
msgid "The third section provides a more technical tutorial that goes into the detailed mechanics of how descriptors work.  Most people don't need this level of detail."
msgstr ""

#: ../../howto/descriptor.rst:30
msgid "Primer"
msgstr ""

#: ../../howto/descriptor.rst:32
msgid "In this primer, we start with the most basic possible example and then we'll add new capabilities one by one."
msgstr ""

#: ../../howto/descriptor.rst:37
msgid "Simple example: A descriptor that returns a constant"
msgstr ""

#: ../../howto/descriptor.rst:39
msgid "The :class:`Ten` class is a descriptor that always returns the constant ``10``::"
msgstr ""

#: ../../howto/descriptor.rst:46
msgid "To use the descriptor, it must be stored as a class variable in another class::"
msgstr ""

#: ../../howto/descriptor.rst:52
msgid "An interactive session shows the difference between normal attribute lookup and descriptor lookup::"
msgstr ""

#: ../../howto/descriptor.rst:61
msgid "In the ``a.x`` attribute lookup, the dot operator finds the value ``5`` stored in the class dictionary.  In the ``a.y`` descriptor lookup, the dot operator calls the descriptor's :meth:`__get__()` method.  That method returns ``10``. Note that the value ``10`` is not stored in either the class dictionary or the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""

#: ../../howto/descriptor.rst:67
msgid "This example shows how a simple descriptor works, but it isn't very useful. For retrieving constants, normal attribute lookup would be better."
msgstr ""

#: ../../howto/descriptor.rst:70
msgid "In the next section, we'll create something more useful, a dynamic lookup."
msgstr ""

#: ../../howto/descriptor.rst:74
msgid "Dynamic lookups"
msgstr ""

#: ../../howto/descriptor.rst:76
msgid "Interesting descriptors typically run computations instead of doing lookups::"
msgstr ""

#: ../../howto/descriptor.rst:93
msgid "An interactive session shows that the lookup is dynamic â€” it computes different, updated answers each time::"
msgstr ""

#: ../../howto/descriptor.rst:107
msgid "Besides showing how descriptors can run computations, this example also reveals the purpose of the parameters to :meth:`__get__`.  The *self* parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is either *g* or *s*, an instance of *Directory*.  It is *obj* parameter that lets the :meth:`__get__` method learn the target directory.  The *objtype* parameter is the class *Directory*."
msgstr ""

#: ../../howto/descriptor.rst:116
msgid "Managed attributes"
msgstr ""

#: ../../howto/descriptor.rst:118
msgid "A popular use for descriptors is managing access to instance data.  The descriptor is assigned to a public attribute in the class dictionary while the actual data is stored as a private attribute in the instance dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods are triggered when the public attribute is accessed."
msgstr ""

#: ../../howto/descriptor.rst:124
msgid "In the following example, *age* is the public attribute and *_age* is the private attribute.  When the public attribute is accessed, the descriptor logs the lookup or update::"
msgstr ""

#: ../../howto/descriptor.rst:155
msgid "An interactive session shows that all access to the managed attribute *age* is logged, but that the regular attribute *name* is not logged::"
msgstr ""

#: ../../howto/descriptor.rst:181
msgid "One major issue with this example is the private name *_age* is hardwired in the *LoggedAgeAccess* class.  That means that each instance can only have one logged attribute and that its name is unchangeable.  In the next example, we'll fix that problem."
msgstr ""

#: ../../howto/descriptor.rst:188
msgid "Customized Names"
msgstr ""

#: ../../howto/descriptor.rst:190
msgid "When a class uses descriptors, it can inform each descriptor about what variable name was used."
msgstr ""

#: ../../howto/descriptor.rst:193
msgid "In this example, the :class:`Person` class has two descriptor instances, *name* and *age*.  When the :class:`Person` class is defined, it makes a callback to :meth:`__set_name__` in *LoggedAccess* so that the field names can be recorded, giving each descriptor its own *public_name* and *private_name*::"
msgstr ""

#: ../../howto/descriptor.rst:229
msgid "An interactive session shows that the :class:`Person` class has called :meth:`__set_name__` so that the field names would be recorded.  Here we call :func:`vars` to lookup the descriptor without triggering it::"
msgstr ""

#: ../../howto/descriptor.rst:238
msgid "The new class now logs access to both *name* and *age*::"
msgstr ""

#: ../../howto/descriptor.rst:247
msgid "The two *Person* instances contain only the private names::"
msgstr ""

#: ../../howto/descriptor.rst:256
msgid "Closing thoughts"
msgstr ""

#: ../../howto/descriptor.rst:258
msgid "A :term:`descriptor` is what we call any object that defines :meth:`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""

#: ../../howto/descriptor.rst:261
msgid "Optionally, descriptors can have a :meth:`__set_name__` method.  This is only used in cases where a descriptor needs to know either the class where it is created or the name of class variable it was assigned to."
msgstr ""

#: ../../howto/descriptor.rst:265
msgid "Descriptors get invoked by the dot operator during attribute lookup.  If a descriptor is accessed indirectly with ``vars(some_class)[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""

#: ../../howto/descriptor.rst:269
msgid "Descriptors only work when used as class variables.  When put in instances, they have no effect."
msgstr ""

#: ../../howto/descriptor.rst:272
msgid "The main motivation for descriptors is to provide a hook allowing objects stored in class variables to control what happens during dotted lookup."
msgstr ""

#: ../../howto/descriptor.rst:275
msgid "Traditionally, the calling class controls what happens during lookup. Descriptors invert that relationship and allow the data being looked-up to have a say in the matter."
msgstr ""

#: ../../howto/descriptor.rst:279
msgid "Descriptors are used throughout the language.  It is how functions turn into bound methods.  Common tools like :func:`classmethod`, :func:`staticmethod`, :func:`property`, and :func:`functools.cached_property` are all implemented as descriptors."
msgstr ""

#: ../../howto/descriptor.rst:286
msgid "Complete Practical Example"
msgstr ""

#: ../../howto/descriptor.rst:288
msgid "In this example, we create a practical and powerful tool for locating notoriously hard to find data corruption bugs."
msgstr ""

#: ../../howto/descriptor.rst:293
msgid "Validator class"
msgstr ""

#: ../../howto/descriptor.rst:295
msgid "A validator is a descriptor for managed attribute access.  Prior to storing any data, it verifies that the new value meets various type and range restrictions.  If those restrictions aren't met, it raises an exception to prevent data corruption at its source."
msgstr ""

#: ../../howto/descriptor.rst:300
msgid "This :class:`Validator` class is both an :term:`abstract base class` and a managed attribute descriptor::"
msgstr ""

#: ../../howto/descriptor.rst:321
msgid "Custom validators need to subclass from :class:`Validator` and supply a :meth:`validate` method to test various restrictions as needed."
msgstr ""

#: ../../howto/descriptor.rst:326
msgid "Custom validators"
msgstr ""

#: ../../howto/descriptor.rst:328
msgid "Here are three practical data validation utilities:"
msgstr ""

#: ../../howto/descriptor.rst:330
msgid ":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ""

#: ../../howto/descriptor.rst:332
msgid ":class:`Number` verifies that a value is either an :class:`int` or :class:`float`.  Optionally, it verifies that a value is between a given minimum or maximum."
msgstr ""

#: ../../howto/descriptor.rst:336
msgid ":class:`String` verifies that a value is a :class:`str`.  Optionally, it validates a given minimum or maximum length.  Optionally, it can test for another predicate as well."
msgstr ""

#: ../../howto/descriptor.rst:394
msgid "Practical use"
msgstr ""

#: ../../howto/descriptor.rst:396
msgid "Here's how the data validators can be used in a real class::"
msgstr ""

#: ../../howto/descriptor.rst:409
msgid "The descriptors prevent invalid instances from being created::"
msgstr ""

#: ../../howto/descriptor.rst:419
msgid "Technical Tutorial"
msgstr ""

#: ../../howto/descriptor.rst:421
msgid "What follows is a more technical tutorial for the mechanics and details of how descriptors work."
msgstr ""

#: ../../howto/descriptor.rst:426
msgid "Abstract"
msgstr ""

#: ../../howto/descriptor.rst:428
msgid "Defines descriptors, summarizes the protocol, and shows how descriptors are called.  Examines a custom descriptor and several built-in Python descriptors including functions, properties, static methods, and class methods.  Shows how each works by giving a pure Python equivalent and a sample application."
msgstr ""

#: ../../howto/descriptor.rst:433
msgid "Learning about descriptors not only provides access to a larger toolset, it creates a deeper understanding of how Python works and an appreciation for the elegance of its design."
msgstr ""

#: ../../howto/descriptor.rst:439
msgid "Definition and Introduction"
msgstr ""

#: ../../howto/descriptor.rst:441
msgid "In general, a descriptor is an object attribute with \"binding behavior\", one whose attribute access has been overridden by methods in the descriptor protocol.  Those methods are :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`.  If any of those methods are defined for an object, it is said to be a :term:`descriptor`."
msgstr ""

#: ../../howto/descriptor.rst:447
msgid "The default behavior for attribute access is to get, set, or delete the attribute from an object's dictionary.  For instance, ``a.x`` has a lookup chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and continuing through the base classes of ``type(a)``. If the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined."
msgstr ""

#: ../../howto/descriptor.rst:456
msgid "Descriptors are a powerful, general purpose protocol.  They are the mechanism behind properties, methods, static methods, class methods, and :func:`super()`.  They are used throughout Python itself.  Descriptors simplify the underlying C code and offer a flexible set of new tools for everyday Python programs."
msgstr ""

#: ../../howto/descriptor.rst:464
msgid "Descriptor Protocol"
msgstr ""

#: ../../howto/descriptor.rst:466
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr ""

#: ../../howto/descriptor.rst:468
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr ""

#: ../../howto/descriptor.rst:470
msgid "``descr.__delete__(self, obj) -> None``"
msgstr ""

#: ../../howto/descriptor.rst:472
msgid "That is all there is to it.  Define any of these methods and an object is considered a descriptor and can override default behavior upon being looked up as an attribute."
msgstr ""

#: ../../howto/descriptor.rst:476
msgid "If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered a data descriptor.  Descriptors that only define :meth:`__get__` are called non-data descriptors (they are typically used for methods but other uses are possible)."
msgstr ""

#: ../../howto/descriptor.rst:481
msgid "Data and non-data descriptors differ in how overrides are calculated with respect to entries in an instance's dictionary.  If an instance's dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence.  If an instance's dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""

#: ../../howto/descriptor.rst:487
msgid "To make a read-only data descriptor, define both :meth:`__get__` and :meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when called.  Defining the :meth:`__set__` method with an exception raising placeholder is enough to make it a data descriptor."
msgstr ""

#: ../../howto/descriptor.rst:494
msgid "Invoking Descriptors"
msgstr ""

#: ../../howto/descriptor.rst:496
msgid "A descriptor can be called directly by its method name.  For example, ``d.__get__(obj)``."
msgstr ""

#: ../../howto/descriptor.rst:499
msgid "But it is more common for a descriptor to be invoked automatically from attribute access.  The expression ``obj.d`` looks up ``d`` in the dictionary of ``obj``.  If ``d`` defines the method :meth:`__get__`, then ``d.__get__(obj)`` is invoked according to the precedence rules listed below."
msgstr ""

#: ../../howto/descriptor.rst:504
msgid "The details of invocation depend on whether ``obj`` is an object, class, or instance of super."
msgstr ""

#: ../../howto/descriptor.rst:507
msgid "**Objects**:  The machinery is in :meth:`object.__getattribute__`."
msgstr ""

#: ../../howto/descriptor.rst:509
msgid "It transforms ``b.x`` into ``type(b).__dict__['x'].__get__(b, type(b))``."
msgstr ""

#: ../../howto/descriptor.rst:511
msgid "The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to :meth:`__getattr__` if provided."
msgstr ""

#: ../../howto/descriptor.rst:515
msgid "The full C implementation can be found in :c:func:`PyObject_GenericGetAttr()` in :source:`Objects/object.c`."
msgstr ""

#: ../../howto/descriptor.rst:518
msgid "**Classes**:  The machinery is in :meth:`type.__getattribute__`."
msgstr ""

#: ../../howto/descriptor.rst:520
msgid "It transforms ``A.x`` into ``A.__dict__['x'].__get__(None, A)``."
msgstr ""

#: ../../howto/descriptor.rst:522
msgid "In pure Python, it looks like this::"
msgstr ""

#: ../../howto/descriptor.rst:531
msgid "**Super**:  The machinery is in the custom :meth:`__getattribute__` method for object returned by :class:`super()`."
msgstr ""

#: ../../howto/descriptor.rst:534
msgid "The attribute lookup ``super(A, obj).m`` searches ``obj.__class__.__mro__`` for the base class ``B`` immediately following ``A`` and then returns ``B.__dict__['m'].__get__(obj, A)``."
msgstr ""

#: ../../howto/descriptor.rst:538
msgid "If not a descriptor, ``m`` is returned unchanged.  If not in the dictionary, ``m`` reverts to a search using :meth:`object.__getattribute__`."
msgstr ""

#: ../../howto/descriptor.rst:541
msgid "The implementation details are in :c:func:`super_getattro()` in :source:`Objects/typeobject.c`.  A pure Python equivalent can be found in `Guido's Tutorial`_."
msgstr ""

#: ../../howto/descriptor.rst:547
msgid "**Summary**:  The details listed above show that the mechanism for descriptors is embedded in the :meth:`__getattribute__()` methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr ""

#: ../../howto/descriptor.rst:551
msgid "The important points to remember are:"
msgstr ""

#: ../../howto/descriptor.rst:553
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr ""

#: ../../howto/descriptor.rst:555
msgid "Classes inherit this machinery from :class:`object`, :class:`type`, or :func:`super`."
msgstr ""

#: ../../howto/descriptor.rst:558
msgid "Overriding :meth:`__getattribute__` prevents automatic descriptor calls because all the descriptor logic is in that method."
msgstr ""

#: ../../howto/descriptor.rst:561
msgid ":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make different calls to :meth:`__get__`.  The first includes the instance and may include the class.  The second puts in ``None`` for the instance and always includes the class."
msgstr ""

#: ../../howto/descriptor.rst:566
msgid "Data descriptors always override instance dictionaries."
msgstr ""

#: ../../howto/descriptor.rst:568
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr ""

#: ../../howto/descriptor.rst:572
msgid "Automatic Name Notification"
msgstr ""

#: ../../howto/descriptor.rst:574
msgid "Sometimes it is desirable for a descriptor to know what class variable name it was assigned to.  When a new class is created, the :class:`type` metaclass scans the dictionary of the new class.  If any of the entries are descriptors and if they define :meth:`__set_name__`, that method is called with two arguments.  The *owner* is the class where the descriptor is used, the *name* is class variable the descriptor was assigned to."
msgstr ""

#: ../../howto/descriptor.rst:581
msgid "The implementation details are in :c:func:`type_new()` and :c:func:`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../../howto/descriptor.rst:584
msgid "Since the update logic is in :meth:`type.__new__`, notifications only take place at the time of class creation.  If descriptors are added to the class afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""

#: ../../howto/descriptor.rst:590
msgid "Descriptor Example"
msgstr ""

#: ../../howto/descriptor.rst:592
msgid "The following code is simplified skeleton showing how data descriptors could be used to implement an `object relational mapping <https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""

#: ../../howto/descriptor.rst:596
msgid "The essential idea is that instances only hold keys to a database table.  The actual data is stored in an external table that is being dynamically updated::"
msgstr ""

#: ../../howto/descriptor.rst:612
msgid "We can use the :class:`Field` to define \"models\" that describe the schema for each table in a database::"
msgstr ""

#: ../../howto/descriptor.rst:634
msgid "An interactive session shows how data is retrieved from the database and how it can be updated::"
msgstr ""

#: ../../howto/descriptor.rst:653
msgid "The descriptor protocol is simple and offers exciting possibilities.  Several use cases are so common that they have been packaged into individual function calls.  Properties, bound methods, static methods, and class methods are all based on the descriptor protocol."
msgstr ""

#: ../../howto/descriptor.rst:660
msgid "Properties"
msgstr ""

#: ../../howto/descriptor.rst:662
msgid "Calling :func:`property` is a succinct way of building a data descriptor that triggers function calls upon access to an attribute.  Its signature is::"
msgstr ""

#: ../../howto/descriptor.rst:667
msgid "The documentation shows a typical use to define a managed attribute ``x``::"
msgstr ""

#: ../../howto/descriptor.rst:675
msgid "To see how :func:`property` is implemented in terms of the descriptor protocol, here is a pure Python equivalent::"
msgstr ""

#: ../../howto/descriptor.rst:715
msgid "The :func:`property` builtin helps whenever a user interface has granted attribute access and then subsequent changes require the intervention of a method."
msgstr ""

#: ../../howto/descriptor.rst:719
msgid "For instance, a spreadsheet class may grant access to a cell value through ``Cell('b10').value``. Subsequent improvements to the program require the cell to be recalculated on every access; however, the programmer does not want to affect existing client code accessing the attribute directly.  The solution is to wrap access to the value attribute in a property data descriptor::"
msgstr ""

#: ../../howto/descriptor.rst:736
msgid "Functions and Methods"
msgstr ""

#: ../../howto/descriptor.rst:738
msgid "Python's object oriented features are built upon a function based environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""

#: ../../howto/descriptor.rst:741
msgid "Functions stored in class dictionaries get turned into methods when invoked. Methods only differ from regular functions in that the object instance is prepended to the other arguments.  By convention, the instance is called *self* but could be called *this* or any other variable name."
msgstr ""

#: ../../howto/descriptor.rst:746
msgid "Methods can be created manually with :class:`types.MethodType` which is roughly equivalent to::"
msgstr ""

#: ../../howto/descriptor.rst:761
msgid "To support automatic creation of methods, functions include the :meth:`__get__` method for binding methods during attribute access.  This means that functions are non-data descriptors which return bound methods during dotted lookup from an instance.  Here's how it works::"
msgstr ""

#: ../../howto/descriptor.rst:775
msgid "Running the following class in the interpreter shows how the function descriptor works in practice::"
msgstr ""

#: ../../howto/descriptor.rst:782
msgid "The function has a :term:`qualified name` attribute to support introspection::"
msgstr ""

#: ../../howto/descriptor.rst:787
msgid "Accessing the function through the class dictionary does not invoke :meth:`__get__`.  Instead, it just returns the underlying function object::"
msgstr ""

#: ../../howto/descriptor.rst:793
msgid "Dotted access from a class calls :meth:`__get__` which just returns the underlying function unchanged::"
msgstr ""

#: ../../howto/descriptor.rst:799
msgid "The interesting behavior occurs during dotted access from an instance.  The dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr ""

#: ../../howto/descriptor.rst:806
msgid "Internally, the bound method stores the underlying function and the bound instance::"
msgstr ""

#: ../../howto/descriptor.rst:815
msgid "If you have ever wondered where *self* comes from in regular methods or where *cls* comes from in class methods, this is it!"
msgstr ""

#: ../../howto/descriptor.rst:820
msgid "Static Methods and Class Methods"
msgstr ""

#: ../../howto/descriptor.rst:822
msgid "Non-data descriptors provide a simple mechanism for variations on the usual patterns of binding functions into methods."
msgstr ""

#: ../../howto/descriptor.rst:825
msgid "To recap, functions have a :meth:`__get__` method so that they can be converted to a method when accessed as attributes.  The non-data descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""

#: ../../howto/descriptor.rst:830
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr ""

#: ../../howto/descriptor.rst:833
msgid "Transformation"
msgstr ""

#: ../../howto/descriptor.rst:833
msgid "Called from an object"
msgstr ""

#: ../../howto/descriptor.rst:833
msgid "Called from a class"
msgstr ""

#: ../../howto/descriptor.rst:836
msgid "function"
msgstr ""

#: ../../howto/descriptor.rst:836
msgid "f(obj, \\*args)"
msgstr ""

#: ../../howto/descriptor.rst:836
#: ../../howto/descriptor.rst:838
#: ../../howto/descriptor.rst:838
msgid "f(\\*args)"
msgstr ""

#: ../../howto/descriptor.rst:838
msgid "staticmethod"
msgstr ""

#: ../../howto/descriptor.rst:840
msgid "classmethod"
msgstr ""

#: ../../howto/descriptor.rst:840
msgid "f(type(obj), \\*args)"
msgstr ""

#: ../../howto/descriptor.rst:840
msgid "f(cls, \\*args)"
msgstr ""

#: ../../howto/descriptor.rst:843
msgid "Static methods return the underlying function without changes.  Calling either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a result, the function becomes identically accessible from either an object or a class."
msgstr ""

#: ../../howto/descriptor.rst:849
msgid "Good candidates for static methods are methods that do not reference the ``self`` variable."
msgstr ""

#: ../../howto/descriptor.rst:852
msgid "For instance, a statistics package may include a container class for experimental data.  The class provides normal methods for computing the average, mean, median, and other descriptive statistics that depend on the data. However, there may be useful functions which are conceptually related but do not depend on the data.  For instance, ``erf(x)`` is handy conversion routine that comes up in statistical work but does not directly depend on a particular dataset. It can be called either from an object or the class:  ``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""

#: ../../howto/descriptor.rst:861
msgid "Since static methods return the underlying function with no changes, the example calls are unexciting::"
msgstr ""

#: ../../howto/descriptor.rst:874
msgid "Using the non-data descriptor protocol, a pure Python version of :func:`staticmethod` would look like this::"
msgstr ""

#: ../../howto/descriptor.rst:886
msgid "Unlike static methods, class methods prepend the class reference to the argument list before calling the function.  This format is the same for whether the caller is an object or a class::"
msgstr ""

#: ../../howto/descriptor.rst:901
msgid "This behavior is useful whenever the function only needs to have a class reference and does not care about any underlying data.  One use for class methods is to create alternate class constructors.  The classmethod :func:`dict.fromkeys` creates a new dictionary from a list of keys.  The pure Python equivalent is::"
msgstr ""

#: ../../howto/descriptor.rst:918
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr ""

#: ../../howto/descriptor.rst:923
msgid "Using the non-data descriptor protocol, a pure Python version of :func:`classmethod` would look like this::"
msgstr ""

#: ../../howto/descriptor.rst:939
msgid "The code path for ``hasattr(obj, '__get__')`` was added in Python 3.9 and makes it possible for :func:`classmethod` to support chained decorators. For example, a classmethod and property could be chained together::"
msgstr ""
