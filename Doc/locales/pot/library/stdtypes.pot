# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-21 01:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr ""

#: ../../library/stdtypes.rst:10
msgid "The following sections describe the standard types that are built into the interpreter."
msgstr ""

#: ../../library/stdtypes.rst:15
msgid "Historically (until release 2.2), Python's built-in types have differed from user-defined types because it was not possible to use the built-in types as the basis for object-oriented inheritance. This limitation no longer exists."
msgstr ""

#: ../../library/stdtypes.rst:22
msgid "The principal built-in types are numerics, sequences, mappings, files, classes, instances and exceptions."
msgstr ""

#: ../../library/stdtypes.rst:27
msgid "Some operations are supported by several object types; in particular, practically all objects can be compared, tested for truth value, and converted to a string (with the :ref:`repr() <func-repr>` function or the slightly different :func:`str` function).  The latter function is implicitly used when an object is written by the :func:`print` function."
msgstr ""

#: ../../library/stdtypes.rst:37
msgid "Truth Value Testing"
msgstr ""

#: ../../library/stdtypes.rst:46
msgid "Any object can be tested for truth value, for use in an :keyword:`if` or :keyword:`while` condition or as operand of the Boolean operations below. The following values are considered false:"
msgstr ""

#: ../../library/stdtypes.rst:52
msgid "``None``"
msgstr ""

#: ../../library/stdtypes.rst:56
msgid "``False``"
msgstr ""

#: ../../library/stdtypes.rst:58
msgid "zero of any numeric type, for example, ``0``, ``0L``, ``0.0``, ``0j``."
msgstr ""

#: ../../library/stdtypes.rst:60
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:62
msgid "any empty mapping, for example, ``{}``."
msgstr ""

#: ../../library/stdtypes.rst:64
msgid "instances of user-defined classes, if the class defines a :meth:`__nonzero__` or :meth:`__len__` method, when that method returns the integer zero or :class:`bool` value ``False``. [1]_"
msgstr ""

#: ../../library/stdtypes.rst:70
msgid "All other values are considered true --- so objects of many types are always true."
msgstr ""

#: ../../library/stdtypes.rst:79
msgid "Operations and built-in functions that have a Boolean result always return ``0`` or ``False`` for false and ``1`` or ``True`` for true, unless otherwise stated. (Important exception: the Boolean operations ``or`` and ``and`` always return one of their operands.)"
msgstr ""

#: ../../library/stdtypes.rst:88
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr ""

#: ../../library/stdtypes.rst:92
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""

#: ../../library/stdtypes.rst:95
#: ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:397
#: ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1656
msgid "Operation"
msgstr ""

#: ../../library/stdtypes.rst:95
#: ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:397
#: ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1656
msgid "Result"
msgstr ""

#: ../../library/stdtypes.rst:95
#: ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1507
#: ../../library/stdtypes.rst:1656
msgid "Notes"
msgstr ""

#: ../../library/stdtypes.rst:97
msgid "``x or y``"
msgstr ""

#: ../../library/stdtypes.rst:97
msgid "if *x* is false, then *y*, else *x*"
msgstr ""

#: ../../library/stdtypes.rst:97
#: ../../library/stdtypes.rst:165
#: ../../library/stdtypes.rst:307
#: ../../library/stdtypes.rst:735
#: ../../library/stdtypes.rst:738
#: ../../library/stdtypes.rst:1513
#: ../../library/stdtypes.rst:1667
msgid "\\(1)"
msgstr ""

#: ../../library/stdtypes.rst:100
msgid "``x and y``"
msgstr ""

#: ../../library/stdtypes.rst:100
msgid "if *x* is false, then *x*, else *y*"
msgstr ""

#: ../../library/stdtypes.rst:100
#: ../../library/stdtypes.rst:321
#: ../../library/stdtypes.rst:323
#: ../../library/stdtypes.rst:744
#: ../../library/stdtypes.rst:1517
#: ../../library/stdtypes.rst:1519
#: ../../library/stdtypes.rst:1673
msgid "\\(2)"
msgstr ""

#: ../../library/stdtypes.rst:103
msgid "``not x``"
msgstr ""

#: ../../library/stdtypes.rst:103
msgid "if *x* is false, then ``True``, else ``False``"
msgstr ""

#: ../../library/stdtypes.rst:103
#: ../../library/stdtypes.rst:318
#: ../../library/stdtypes.rst:747
#: ../../library/stdtypes.rst:1521
#: ../../library/stdtypes.rst:1523
#: ../../library/stdtypes.rst:1525
#: ../../library/stdtypes.rst:1527
#: ../../library/stdtypes.rst:1676
msgid "\\(3)"
msgstr ""

#: ../../library/stdtypes.rst:112
#: ../../library/stdtypes.rst:172
#: ../../library/stdtypes.rst:345
#: ../../library/stdtypes.rst:462
#: ../../library/stdtypes.rst:787
#: ../../library/stdtypes.rst:1550
#: ../../library/stdtypes.rst:1703
msgid "Notes:"
msgstr ""

#: ../../library/stdtypes.rst:115
msgid "This is a short-circuit operator, so it only evaluates the second argument if the first one is false."
msgstr ""

#: ../../library/stdtypes.rst:119
msgid "This is a short-circuit operator, so it only evaluates the second argument if the first one is true."
msgstr ""

#: ../../library/stdtypes.rst:123
msgid "``not`` has a lower priority than non-Boolean operators, so ``not a == b`` is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""

#: ../../library/stdtypes.rst:130
msgid "Comparisons"
msgstr ""

#: ../../library/stdtypes.rst:144
msgid "Comparison operations are supported by all objects.  They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x < y and y <= z``, except that *y* is evaluated only once (but in both cases *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""

#: ../../library/stdtypes.rst:150
msgid "This table summarizes the comparison operations:"
msgstr ""

#: ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:1484
#: ../../library/stdtypes.rst:1507
msgid "Meaning"
msgstr ""

#: ../../library/stdtypes.rst:155
msgid "``<``"
msgstr ""

#: ../../library/stdtypes.rst:155
msgid "strictly less than"
msgstr ""

#: ../../library/stdtypes.rst:157
msgid "``<=``"
msgstr ""

#: ../../library/stdtypes.rst:157
msgid "less than or equal"
msgstr ""

#: ../../library/stdtypes.rst:159
msgid "``>``"
msgstr ""

#: ../../library/stdtypes.rst:159
msgid "strictly greater than"
msgstr ""

#: ../../library/stdtypes.rst:161
msgid "``>=``"
msgstr ""

#: ../../library/stdtypes.rst:161
msgid "greater than or equal"
msgstr ""

#: ../../library/stdtypes.rst:163
msgid "``==``"
msgstr ""

#: ../../library/stdtypes.rst:163
msgid "equal"
msgstr ""

#: ../../library/stdtypes.rst:165
msgid "``!=``"
msgstr ""

#: ../../library/stdtypes.rst:165
msgid "not equal"
msgstr ""

#: ../../library/stdtypes.rst:167
msgid "``is``"
msgstr ""

#: ../../library/stdtypes.rst:167
msgid "object identity"
msgstr ""

#: ../../library/stdtypes.rst:169
msgid "``is not``"
msgstr ""

#: ../../library/stdtypes.rst:169
msgid "negated object identity"
msgstr ""

#: ../../library/stdtypes.rst:175
msgid "``!=`` can also be written ``<>``, but this is an obsolete usage kept for backwards compatibility only. New code should always use ``!=``."
msgstr ""

#: ../../library/stdtypes.rst:183
msgid "Objects of different types, except different numeric types and different string types, never compare equal; such objects are ordered consistently but arbitrarily (so that sorting a heterogeneous array yields a consistent result). Furthermore, some types (for example, file objects) support only a degenerate notion of comparison where any two objects of that type are unequal.  Again, such objects are ordered arbitrarily but consistently. The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:`TypeError` exception when any operand is a complex number."
msgstr ""

#: ../../library/stdtypes.rst:201
msgid "Non-identical instances of a class normally compare as non-equal unless the class defines the :meth:`__eq__` method or the :meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:204
msgid "Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines either enough of the rich comparison methods (:meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:`__ge__`) or the :meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:211
msgid "Objects of different types except numbers are ordered by their type names; objects of the same types that don't support proper comparison are ordered by their address."
msgstr ""

#: ../../library/stdtypes.rst:219
msgid "Two more operations with the same syntactic priority, ``in`` and ``not in``, are supported only by sequence types (below)."
msgstr ""

#: ../../library/stdtypes.rst:226
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`long`, :class:`complex`"
msgstr ""

#: ../../library/stdtypes.rst:237
msgid "There are four distinct numeric types: :dfn:`plain integers`, :dfn:`long integers`, :dfn:`floating point numbers`, and :dfn:`complex numbers`. In addition, Booleans are a subtype of plain integers. Plain integers (also just called :dfn:`integers`) are implemented using :c:type:`long` in C, which gives them at least 32 bits of precision (``sys.maxint`` is always set to the maximum plain integer value for the current platform, the minimum value is ``-sys.maxint - 1``).  Long integers have unlimited precision.  Floating point numbers are usually implemented using :c:type:`double` in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in :data:`sys.float_info`.  Complex numbers have a real and imaginary part, which are each a floating point number.  To extract these parts from a complex number *z*, use ``z.real`` and ``z.imag``. (The standard library includes additional numeric types, :mod:`fractions` that hold rationals, and :mod:`decimal` that hold floating-point numbers with user-definable precision.)"
msgstr ""

#: ../../library/stdtypes.rst:262
msgid "Numbers are created by numeric literals or as the result of built-in functions and operators.  Unadorned integer literals (including binary, hex, and octal numbers) yield plain integers unless the value they denote is too large to be represented as a plain integer, in which case they yield a long integer. Integer literals with an ``'L'`` or ``'l'`` suffix yield long integers (``'L'`` is preferred because ``1l`` looks too much like eleven!).  Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending ``'j'`` or ``'J'`` to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts."
msgstr ""

#: ../../library/stdtypes.rst:287
msgid "Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the \"narrower\" type is widened to that of the other, where plain integer is narrower than long integer is narrower than floating point is narrower than complex. Comparisons between numbers of mixed type use the same rule. [2]_ The constructors :func:`int`, :func:`long`, :func:`float`, and :func:`complex` can be used to produce numbers of a specific type."
msgstr ""

#: ../../library/stdtypes.rst:295
msgid "All built-in numeric types support the following operations. See :ref:`power` and later sections for the operators' priorities."
msgstr ""

#: ../../library/stdtypes.rst:301
msgid "``x + y``"
msgstr ""

#: ../../library/stdtypes.rst:301
msgid "sum of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:303
msgid "``x - y``"
msgstr ""

#: ../../library/stdtypes.rst:303
msgid "difference of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:305
msgid "``x * y``"
msgstr ""

#: ../../library/stdtypes.rst:305
msgid "product of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:307
msgid "``x / y``"
msgstr ""

#: ../../library/stdtypes.rst:307
msgid "quotient of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:309
msgid "``x // y``"
msgstr ""

#: ../../library/stdtypes.rst:309
msgid "(floored) quotient of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:309
msgid "(4)(5)"
msgstr ""

#: ../../library/stdtypes.rst:312
msgid "``x % y``"
msgstr ""

#: ../../library/stdtypes.rst:312
msgid "remainder of ``x / y``"
msgstr ""

#: ../../library/stdtypes.rst:312
#: ../../library/stdtypes.rst:1529
#: ../../library/stdtypes.rst:1533
#: ../../library/stdtypes.rst:1685
#: ../../library/stdtypes.rst:1694
msgid "\\(4)"
msgstr ""

#: ../../library/stdtypes.rst:314
msgid "``-x``"
msgstr ""

#: ../../library/stdtypes.rst:314
msgid "*x* negated"
msgstr ""

#: ../../library/stdtypes.rst:316
msgid "``+x``"
msgstr ""

#: ../../library/stdtypes.rst:316
msgid "*x* unchanged"
msgstr ""

#: ../../library/stdtypes.rst:318
msgid "``abs(x)``"
msgstr ""

#: ../../library/stdtypes.rst:318
msgid "absolute value or magnitude of *x*"
msgstr ""

#: ../../library/stdtypes.rst:321
msgid "``int(x)``"
msgstr ""

#: ../../library/stdtypes.rst:321
msgid "*x* converted to integer"
msgstr ""

#: ../../library/stdtypes.rst:323
msgid "``long(x)``"
msgstr ""

#: ../../library/stdtypes.rst:323
msgid "*x* converted to long integer"
msgstr ""

#: ../../library/stdtypes.rst:325
msgid "``float(x)``"
msgstr ""

#: ../../library/stdtypes.rst:325
msgid "*x* converted to floating point"
msgstr ""

#: ../../library/stdtypes.rst:325
#: ../../library/stdtypes.rst:741
#: ../../library/stdtypes.rst:1543
#: ../../library/stdtypes.rst:1691
msgid "\\(6)"
msgstr ""

#: ../../library/stdtypes.rst:327
msgid "``complex(re,im)``"
msgstr ""

#: ../../library/stdtypes.rst:327
msgid "a complex number with real part *re*, imaginary part *im*. *im* defaults to zero."
msgstr ""

#: ../../library/stdtypes.rst:331
msgid "``c.conjugate()``"
msgstr ""

#: ../../library/stdtypes.rst:331
msgid "conjugate of the complex number *c*. (Identity on real numbers)"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "``divmod(x, y)``"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "the pair ``(x // y, x % y)``"
msgstr ""

#: ../../library/stdtypes.rst:334
#: ../../library/stdtypes.rst:749
msgid "(3)(4)"
msgstr ""

#: ../../library/stdtypes.rst:336
msgid "``pow(x, y)``"
msgstr ""

#: ../../library/stdtypes.rst:336
#: ../../library/stdtypes.rst:338
msgid "*x* to the power *y*"
msgstr ""

#: ../../library/stdtypes.rst:336
msgid "(3)(7)"
msgstr ""

#: ../../library/stdtypes.rst:338
msgid "``x ** y``"
msgstr ""

#: ../../library/stdtypes.rst:338
#: ../../library/stdtypes.rst:1515
#: ../../library/stdtypes.rst:1696
msgid "\\(7)"
msgstr ""

#: ../../library/stdtypes.rst:352
msgid "For (plain or long) integer division, the result is an integer. The result is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is -1, and (-1)/(-2) is 0.  Note that the result is a long integer if either operand is a long integer, regardless of the numeric value."
msgstr ""

#: ../../library/stdtypes.rst:365
msgid "Conversion from floats using :func:`int` or :func:`long` truncates toward zero like the related function, :func:`math.trunc`.  Use the function :func:`math.floor` to round downward and :func:`math.ceil` to round upward."
msgstr ""

#: ../../library/stdtypes.rst:371
msgid "See :ref:`built-in-funcs` for a full description."
msgstr ""

#: ../../library/stdtypes.rst:374
msgid "The floor division operator, the modulo operator, and the :func:`divmod` function are no longer defined for complex numbers.  Instead, convert to a floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../library/stdtypes.rst:380
msgid "Also referred to as integer division.  The resultant value is a whole integer, though the result's type is not necessarily int."
msgstr ""

#: ../../library/stdtypes.rst:384
msgid "float also accepts the strings \"nan\" and \"inf\" with an optional prefix \"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""

#: ../../library/stdtypes.rst:390
msgid "Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for programming languages."
msgstr ""

#: ../../library/stdtypes.rst:393
msgid "All :class:`numbers.Real` types (:class:`int`, :class:`long`, and :class:`float`) also include the following operations:"
msgstr ""

#: ../../library/stdtypes.rst:399
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ""

#: ../../library/stdtypes.rst:399
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr ""

#: ../../library/stdtypes.rst:402
msgid ":func:`round(x[, n]) <round>`"
msgstr ""

#: ../../library/stdtypes.rst:402
msgid "*x* rounded to *n* digits, rounding ties away from zero. If *n* is omitted, it defaults to 0."
msgstr ""

#: ../../library/stdtypes.rst:406
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ""

#: ../../library/stdtypes.rst:406
msgid "the greatest integer as a float <= *x*"
msgstr ""

#: ../../library/stdtypes.rst:409
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ""

#: ../../library/stdtypes.rst:409
msgid "the least integer as a float >= *x*"
msgstr ""

#: ../../library/stdtypes.rst:419
msgid "Bitwise Operations on Integer Types"
msgstr ""

#: ../../library/stdtypes.rst:433
msgid "Bitwise operations only make sense for integers.  Negative numbers are treated as their 2's complement value (this assumes a sufficiently large number of bits that no overflow occurs during the operation)."
msgstr ""

#: ../../library/stdtypes.rst:437
msgid "The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation ``~`` has the same priority as the other unary numeric operations (``+`` and ``-``)."
msgstr ""

#: ../../library/stdtypes.rst:441
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""

#: ../../library/stdtypes.rst:446
msgid "``x | y``"
msgstr ""

#: ../../library/stdtypes.rst:446
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:449
msgid "``x ^ y``"
msgstr ""

#: ../../library/stdtypes.rst:449
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:452
msgid "``x & y``"
msgstr ""

#: ../../library/stdtypes.rst:452
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:455
msgid "``x << n``"
msgstr ""

#: ../../library/stdtypes.rst:455
msgid "*x* shifted left by *n* bits"
msgstr ""

#: ../../library/stdtypes.rst:455
msgid "(1)(2)"
msgstr ""

#: ../../library/stdtypes.rst:457
msgid "``x >> n``"
msgstr ""

#: ../../library/stdtypes.rst:457
msgid "*x* shifted right by *n* bits"
msgstr ""

#: ../../library/stdtypes.rst:457
msgid "(1)(3)"
msgstr ""

#: ../../library/stdtypes.rst:459
msgid "``~x``"
msgstr ""

#: ../../library/stdtypes.rst:459
msgid "the bits of *x* inverted"
msgstr ""

#: ../../library/stdtypes.rst:465
msgid "Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""

#: ../../library/stdtypes.rst:468
msgid "A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``.  A long integer is returned if the result exceeds the range of plain integers."
msgstr ""

#: ../../library/stdtypes.rst:472
msgid "A right shift by *n* bits is equivalent to division by ``pow(2, n)``."
msgstr ""

#: ../../library/stdtypes.rst:476
msgid "Additional Methods on Integer Types"
msgstr ""

#: ../../library/stdtypes.rst:478
msgid "The integer types implement the :class:`numbers.Integral` :term:`abstract base class`. In addition, they provide one more method:"
msgstr ""

#: ../../library/stdtypes.rst:484
msgid "Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros::"
msgstr ""

#: ../../library/stdtypes.rst:493
msgid "More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. Equivalently, when ``abs(x)`` is small enough to have a correctly rounded logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x.bit_length()`` returns ``0``."
msgstr ""

#: ../../library/stdtypes.rst:499
msgid "Equivalent to::"
msgstr ""

#: ../../library/stdtypes.rst:510
msgid "Additional Methods on Float"
msgstr ""

#: ../../library/stdtypes.rst:512
msgid "The float type implements the :class:`numbers.Real` :term:`abstract base class`. float also has the following additional methods."
msgstr ""

#: ../../library/stdtypes.rst:517
msgid "Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.  Raises :exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""

#: ../../library/stdtypes.rst:526
msgid "Return ``True`` if the float instance is finite with integral value, and ``False`` otherwise::"
msgstr ""

#: ../../library/stdtypes.rst:536
msgid "Two methods support conversion to and from hexadecimal strings.  Since Python's floats are stored internally as binary numbers, converting a float to or from a *decimal* string usually involves a small rounding error.  In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers.  This can be useful when debugging, and in numerical work."
msgstr ""

#: ../../library/stdtypes.rst:547
msgid "Return a representation of a floating-point number as a hexadecimal string.  For finite floating-point numbers, this representation will always include a leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""

#: ../../library/stdtypes.rst:557
msgid "Class method to return the float represented by a hexadecimal string *s*.  The string *s* may have leading and trailing whitespace."
msgstr ""

#: ../../library/stdtypes.rst:564
msgid "Note that :meth:`float.hex` is an instance method, while :meth:`float.fromhex` is a class method."
msgstr ""

#: ../../library/stdtypes.rst:567
msgid "A hexadecimal string takes the form::"
msgstr ""

#: ../../library/stdtypes.rst:571
msgid "where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and ``fraction`` are strings of hexadecimal digits, and ``exponent`` is a decimal integer with an optional leading sign.  Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In particular, the output of :meth:`float.hex` is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted by :meth:`float.fromhex`."
msgstr ""

#: ../../library/stdtypes.rst:584
msgid "Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string ``0x3.a7p10`` represents the floating-point number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""

#: ../../library/stdtypes.rst:594
msgid "Applying the reverse conversion to ``3740.0`` gives a different hexadecimal string representing the same number::"
msgstr ""

#: ../../library/stdtypes.rst:604
msgid "Iterator Types"
msgstr ""

#: ../../library/stdtypes.rst:614
msgid "Python supports a concept of iteration over containers.  This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration.  Sequences, described below in more detail, always support the iteration methods."
msgstr ""

#: ../../library/stdtypes.rst:619
msgid "One method needs to be defined for container objects to provide iteration support:"
msgstr ""

#: ../../library/stdtypes.rst:626
msgid "Return an iterator object.  The object is required to support the iterator protocol described below.  If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types.  (An example of an object supporting multiple forms of iteration would be a tree structure which supports both breadth-first and depth-first traversal.)  This method corresponds to the :c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:635
msgid "The iterator objects themselves are required to support the following two methods, which together form the :dfn:`iterator protocol`:"
msgstr ""

#: ../../library/stdtypes.rst:641
msgid "Return the iterator object itself.  This is required to allow both containers and iterators to be used with the :keyword:`for` and :keyword:`in` statements. This method corresponds to the :c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:649
msgid "Return the next item from the container.  If there are no further items, raise the :exc:`StopIteration` exception.  This method corresponds to the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for Python objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:654
msgid "Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms.  The specific types are not important beyond their implementation of the iterator protocol."
msgstr ""

#: ../../library/stdtypes.rst:659
msgid "The intention of the protocol is that once an iterator's :meth:`~iterator.next` method raises :exc:`StopIteration`, it will continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.  (This constraint was added in Python 2.3; in Python 2.2, various iterators are broken according to this rule.)"
msgstr ""

#: ../../library/stdtypes.rst:669
msgid "Generator Types"
msgstr ""

#: ../../library/stdtypes.rst:671
msgid "Python's :term:`generator`\\s provide a convenient way to implement the iterator protocol.  If a container object's :meth:`__iter__` method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the :meth:`~iterator.__iter__` and :meth:`~iterator.next` methods.  More information about generators can be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../library/stdtypes.rst:682
msgid "Sequence Types --- :class:`str`, :class:`unicode`, :class:`list`, :class:`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"
msgstr ""

#: ../../library/stdtypes.rst:684
msgid "There are seven sequence types: strings, Unicode strings, lists, tuples, bytearrays, buffers, and xrange objects."
msgstr ""

#: ../../library/stdtypes.rst:687
msgid "For other containers see the built in :class:`dict` and :class:`set` classes, and the :mod:`collections` module."
msgstr ""

#: ../../library/stdtypes.rst:701
msgid "String literals are written in single or double quotes: ``'xyzzy'``, ``\"frobozz\"``.  See :ref:`strings` for more about string literals. Unicode strings are much like strings, but are specified in the syntax using a preceding ``'u'`` character: ``u'abc'``, ``u\"def\"``. In addition to the functionality described here, there are also string-specific methods described in the :ref:`string-methods` section. Lists are constructed with square brackets, separating items with commas: ``[a, b, c]``. Tuples are constructed by the comma operator (not within square brackets), with or without enclosing parentheses, but an empty tuple must have the enclosing parentheses, such as ``a, b, c`` or ``()``.  A single item tuple must have a trailing comma, such as ``(d,)``."
msgstr ""

#: ../../library/stdtypes.rst:713
msgid "Bytearray objects are created with the built-in function :func:`bytearray`."
msgstr ""

#: ../../library/stdtypes.rst:715
msgid "Buffer objects are not directly supported by Python syntax, but can be created by calling the built-in function :func:`buffer`.  They don't support concatenation or repetition."
msgstr ""

#: ../../library/stdtypes.rst:719
msgid "Objects of type xrange are similar to buffers in that there is no specific syntax to create them, but they are created using the :func:`xrange` function.  They don't support slicing, concatenation or repetition, and using ``in``, ``not in``, :func:`min` or :func:`max` on them is inefficient."
msgstr ""

#: ../../library/stdtypes.rst:724
msgid "Most sequence types support the following operations.  The ``in`` and ``not in`` operations have the same priorities as the comparison operations.  The ``+`` and ``*`` operations have the same priority as the corresponding numeric operations. [3]_ Additional methods are provided for :ref:`typesseq-mutable`."
msgstr ""

#: ../../library/stdtypes.rst:729
msgid "This table lists the sequence operations sorted in ascending priority. In the table, *s* and *t* are sequences of the same type; *n*, *i* and *j* are integers:"
msgstr ""

#: ../../library/stdtypes.rst:735
msgid "``x in s``"
msgstr ""

#: ../../library/stdtypes.rst:735
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""

#: ../../library/stdtypes.rst:738
msgid "``x not in s``"
msgstr ""

#: ../../library/stdtypes.rst:738
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""

#: ../../library/stdtypes.rst:741
msgid "``s + t``"
msgstr ""

#: ../../library/stdtypes.rst:741
msgid "the concatenation of *s* and *t*"
msgstr ""

#: ../../library/stdtypes.rst:744
msgid "``s * n, n * s``"
msgstr ""

#: ../../library/stdtypes.rst:744
msgid "equivalent to adding *s* to itself *n* times"
msgstr ""

#: ../../library/stdtypes.rst:747
msgid "``s[i]``"
msgstr ""

#: ../../library/stdtypes.rst:747
msgid "*i*\\ th item of *s*, origin 0"
msgstr ""

#: ../../library/stdtypes.rst:749
msgid "``s[i:j]``"
msgstr ""

#: ../../library/stdtypes.rst:749
msgid "slice of *s* from *i* to *j*"
msgstr ""

#: ../../library/stdtypes.rst:751
msgid "``s[i:j:k]``"
msgstr ""

#: ../../library/stdtypes.rst:751
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""

#: ../../library/stdtypes.rst:751
msgid "(3)(5)"
msgstr ""

#: ../../library/stdtypes.rst:754
msgid "``len(s)``"
msgstr ""

#: ../../library/stdtypes.rst:754
msgid "length of *s*"
msgstr ""

#: ../../library/stdtypes.rst:756
msgid "``min(s)``"
msgstr ""

#: ../../library/stdtypes.rst:756
msgid "smallest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:758
msgid "``max(s)``"
msgstr ""

#: ../../library/stdtypes.rst:758
msgid "largest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:760
msgid "``s.index(x)``"
msgstr ""

#: ../../library/stdtypes.rst:760
msgid "index of the first occurrence of *x* in *s*"
msgstr ""

#: ../../library/stdtypes.rst:763
#: ../../library/stdtypes.rst:1682
msgid "``s.count(x)``"
msgstr ""

#: ../../library/stdtypes.rst:763
msgid "total number of occurrences of *x* in *s*"
msgstr ""

#: ../../library/stdtypes.rst:767
msgid "Sequence types also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../library/stdtypes.rst:790
msgid "When *s* is a string or Unicode string object the ``in`` and ``not in`` operations act like a substring test.  In Python versions before 2.3, *x* had to be a string of length 1. In Python 2.3 and beyond, *x* may be a string of any length."
msgstr ""

#: ../../library/stdtypes.rst:796
msgid "Values of *n* less than ``0`` are treated as ``0`` (which yields an empty sequence of the same type as *s*).  Note that items in the sequence *s* are not copied; they are referenced multiple times.  This often haunts new Python programmers; consider:"
msgstr ""

#: ../../library/stdtypes.rst:808
msgid "What has happened is that ``[[]]`` is a one-element list containing an empty list, so all three elements of ``[[]] * 3`` are references to this single empty list.  Modifying any of the elements of ``lists`` modifies this single list. You can create a list of different lists this way:"
msgstr ""

#: ../../library/stdtypes.rst:820
msgid "Further explanation is available in the FAQ entry :ref:`faq-multidimensional-list`."
msgstr ""

#: ../../library/stdtypes.rst:824
msgid "If *i* or *j* is negative, the index is relative to the end of sequence *s*: ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is still ``0``."
msgstr ""

#: ../../library/stdtypes.rst:829
msgid "The slice of *s* from *i* to *j* is defined as the sequence of items with index *k* such that ``i <= k < j``.  If *i* or *j* is greater than ``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If *j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal to *j*, the slice is empty."
msgstr ""

#: ../../library/stdtypes.rst:836
msgid "The slice of *s* from *i* to *j* with step *k* is defined as the sequence of items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, stopping when *j* is reached (but never including *j*).  When *k* is positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When *k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values (which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is ``None``, it is treated like ``1``."
msgstr ""

#: ../../library/stdtypes.rst:849
msgid "If *s* and *t* are both strings, some Python implementations such as CPython can usually perform an in-place optimization for assignments of the form ``s = s + t`` or ``s += t``.  When applicable, this optimization makes quadratic run-time much less likely.  This optimization is both version and implementation dependent.  For performance sensitive code, it is preferable to use the :meth:`str.join` method which assures consistent linear concatenation performance across versions and implementations."
msgstr ""

#: ../../library/stdtypes.rst:857
msgid "Formerly, string concatenation never occurred in-place."
msgstr ""

#: ../../library/stdtypes.rst:864
msgid "String Methods"
msgstr ""

#: ../../library/stdtypes.rst:868
msgid "Below are listed the string methods which both 8-bit strings and Unicode objects support.  Some of them are also available on :class:`bytearray` objects."
msgstr ""

#: ../../library/stdtypes.rst:872
msgid "In addition, Python's strings support the sequence type methods described in the :ref:`typesseq` section. To output formatted strings use template strings or the ``%`` operator described in the :ref:`string-formatting` section. Also, see the :mod:`re` module for string functions based on regular expressions."
msgstr ""

#: ../../library/stdtypes.rst:880
msgid "Return a copy of the string with its first character capitalized and the rest lowercased."
msgstr ""

#: ../../library/stdtypes.rst:883
#: ../../library/stdtypes.rst:1019
#: ../../library/stdtypes.rst:1027
#: ../../library/stdtypes.rst:1035
#: ../../library/stdtypes.rst:1043
#: ../../library/stdtypes.rst:1051
#: ../../library/stdtypes.rst:1060
#: ../../library/stdtypes.rst:1068
#: ../../library/stdtypes.rst:1094
#: ../../library/stdtypes.rst:1322
#: ../../library/stdtypes.rst:1350
#: ../../library/stdtypes.rst:1387
msgid "For 8-bit strings, this method is locale-dependent."
msgstr ""

#: ../../library/stdtypes.rst:888
msgid "Return centered in a string of length *width*. Padding is done using the specified *fillchar* (default is a space)."
msgstr ""

#: ../../library/stdtypes.rst:891
#: ../../library/stdtypes.rst:1085
#: ../../library/stdtypes.rst:1149
msgid "Support for the *fillchar* argument."
msgstr ""

#: ../../library/stdtypes.rst:897
msgid "Return the number of non-overlapping occurrences of substring *sub* in the range [*start*, *end*].  Optional arguments *start* and *end* are interpreted as in slice notation."
msgstr ""

#: ../../library/stdtypes.rst:904
msgid "Decodes the string using the codec registered for *encoding*. *encoding* defaults to the default string encoding.  *errors* may be given to set a different error handling scheme.  The default is ``'strict'``, meaning that encoding errors raise :exc:`UnicodeError`.  Other possible values are ``'ignore'``, ``'replace'`` and any other name registered via :func:`codecs.register_error`, see section :ref:`codec-base-classes`."
msgstr ""

#: ../../library/stdtypes.rst:913
msgid "Support for other error handling schemes added."
msgstr ""

#: ../../library/stdtypes.rst:916
#: ../../library/stdtypes.rst:936
msgid "Support for keyword arguments added."
msgstr ""

#: ../../library/stdtypes.rst:921
msgid "Return an encoded version of the string.  Default encoding is the current default string encoding.  *errors* may be given to set a different error handling scheme.  The default for *errors* is ``'strict'``, meaning that encoding errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other name registered via :func:`codecs.register_error`, see section :ref:`codec-base-classes`. For a list of possible encodings, see section :ref:`standard-encodings`."
msgstr ""

#: ../../library/stdtypes.rst:932
msgid "Support for ``'xmlcharrefreplace'`` and ``'backslashreplace'`` and other error handling schemes added."
msgstr ""

#: ../../library/stdtypes.rst:941
msgid "Return ``True`` if the string ends with the specified *suffix*, otherwise return ``False``.  *suffix* can also be a tuple of suffixes to look for.  With optional *start*, test beginning at that position.  With optional *end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:946
msgid "Accept tuples as *suffix*."
msgstr ""

#: ../../library/stdtypes.rst:952
msgid "Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size.  Tab positions occur every *tabsize* characters (default is 8, giving tab positions at columns 0, 8, 16 and so on).  To expand the string, the current column is set to zero and the string is examined character by character.  If the character is a tab (``\\t``), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.)  If the character is a newline (``\\n``) or return (``\\r``), it is copied and the current column is reset to zero.  Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed."
msgstr ""

#: ../../library/stdtypes.rst:973
msgid "Return the lowest index in the string where substring *sub* is found within the slice ``s[start:end]``.  Optional arguments *start* and *end* are interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:979
msgid "The :meth:`~str.find` method should be used only if you need to know the position of *sub*.  To check if *sub* is a substring or not, use the :keyword:`in` operator::"
msgstr ""

#: ../../library/stdtypes.rst:989
msgid "Perform a string formatting operation.  The string on which this method is called can contain literal text or replacement fields delimited by braces ``{}``.  Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument.  Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument."
msgstr ""

#: ../../library/stdtypes.rst:999
msgid "See :ref:`formatstrings` for a description of the various formatting options that can be specified in format strings."
msgstr ""

#: ../../library/stdtypes.rst:1002
msgid "This method of string formatting is the new standard in Python 3, and should be preferred to the ``%`` formatting described in :ref:`string-formatting` in new code."
msgstr ""

#: ../../library/stdtypes.rst:1011
msgid "Like :meth:`find`, but raise :exc:`ValueError` when the substring is not found."
msgstr ""

#: ../../library/stdtypes.rst:1016
msgid "Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1024
msgid "Return true if all characters in the string are alphabetic and there is at least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1032
msgid "Return true if all characters in the string are digits and there is at least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1040
msgid "Return true if all cased characters [4]_ in the string are lowercase and there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1048
msgid "Return true if there are only whitespace characters in the string and there is at least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1056
msgid "Return true if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1065
msgid "Return true if all cased characters [4]_ in the string are uppercase and there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1073
msgid "Return a string which is the concatenation of the strings in *iterable*. A :exc:`TypeError` will be raised if there are any non-string values in *iterable*, including :class:`bytes` objects.  The separator between elements is the string providing this method."
msgstr ""

#: ../../library/stdtypes.rst:1081
msgid "Return the string left justified in a string of length *width*. Padding is done using the specified *fillchar* (default is a space).  The original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1091
msgid "Return a copy of the string with all the cased characters [4]_ converted to lowercase."
msgstr ""

#: ../../library/stdtypes.rst:1099
msgid "Return a copy of the string with leading characters removed.  The *chars* argument is a string specifying the set of characters to be removed.  If omitted or ``None``, the *chars* argument defaults to removing whitespace.  The *chars* argument is not a prefix; rather, all combinations of its values are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1109
#: ../../library/stdtypes.rst:1186
#: ../../library/stdtypes.rst:1313
msgid "Support for the *chars* argument."
msgstr ""

#: ../../library/stdtypes.rst:1115
msgid "Split the string at the first occurrence of *sep*, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator.  If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings."
msgstr ""

#: ../../library/stdtypes.rst:1125
msgid "Return a copy of the string with all occurrences of substring *old* replaced by *new*.  If the optional argument *count* is given, only the first *count* occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:1132
msgid "Return the highest index in the string where substring *sub* is found, such that *sub* is contained within ``s[start:end]``.  Optional arguments *start* and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""

#: ../../library/stdtypes.rst:1139
msgid "Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:1145
msgid "Return the string right justified in a string of length *width*. Padding is done using the specified *fillchar* (default is a space). The original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1155
msgid "Split the string at the last occurrence of *sep*, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator.  If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself."
msgstr ""

#: ../../library/stdtypes.rst:1165
msgid "Return a list of the words in the string, using *sep* as the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are done, the *rightmost* ones.  If *sep* is not specified or ``None``, any whitespace string is a separator.  Except for splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is described in detail below."
msgstr ""

#: ../../library/stdtypes.rst:1176
msgid "Return a copy of the string with trailing characters removed.  The *chars* argument is a string specifying the set of characters to be removed.  If omitted or ``None``, the *chars* argument defaults to removing whitespace.  The *chars* argument is not a suffix; rather, all combinations of its values are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1192
msgid "Return a list of the words in the string, using *sep* as the delimiter string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not specified or ``-1``, then there is no limit on the number of splits (all possible splits are made)."
msgstr ""

#: ../../library/stdtypes.rst:1198
msgid "If *sep* is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns ``['1', '', '2']``).  The *sep* argument may consist of multiple characters (for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). Splitting an empty string with a specified separator returns ``['']``."
msgstr ""

#: ../../library/stdtypes.rst:1204
msgid "If *sep* is not specified or is ``None``, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.  Consequently, splitting an empty string or a string consisting of just whitespace with a ``None`` separator returns ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:1211
msgid "For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'  1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr ""

#: ../../library/stdtypes.rst:1220
msgid "Return a list of the lines in the string, breaking at line boundaries. This method uses the :term:`universal newlines` approach to splitting lines. Line breaks are not included in the resulting list unless *keepends* is given and true."
msgstr ""

#: ../../library/stdtypes.rst:1225
msgid "Python recognizes ``\"\\r\"``, ``\"\\n\"``, and ``\"\\r\\n\"`` as line boundaries for 8-bit strings."
msgstr ""

#: ../../library/stdtypes.rst:1228
msgid "For example::"
msgstr ""

#: ../../library/stdtypes.rst:1235
msgid "Unlike :meth:`~str.split` when a delimiter string *sep* is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line::"
msgstr ""

#: ../../library/stdtypes.rst:1244
msgid "For comparison, ``split('\\n')`` gives::"
msgstr ""

#: ../../library/stdtypes.rst:1253
msgid "Return a list of the lines in the string, like :meth:`str.splitlines`. However, the Unicode method splits on the following line boundaries, which are a superset of the :term:`universal newlines` recognized for 8-bit strings."
msgstr ""

#: ../../library/stdtypes.rst:1259
msgid "Representation"
msgstr ""

#: ../../library/stdtypes.rst:1259
msgid "Description"
msgstr ""

#: ../../library/stdtypes.rst:1261
msgid "``\\n``"
msgstr ""

#: ../../library/stdtypes.rst:1261
msgid "Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:1263
msgid "``\\r``"
msgstr ""

#: ../../library/stdtypes.rst:1263
msgid "Carriage Return"
msgstr ""

#: ../../library/stdtypes.rst:1265
msgid "``\\r\\n``"
msgstr ""

#: ../../library/stdtypes.rst:1265
msgid "Carriage Return + Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:1267
msgid "``\\v`` or ``\\x0b``"
msgstr ""

#: ../../library/stdtypes.rst:1267
msgid "Line Tabulation"
msgstr ""

#: ../../library/stdtypes.rst:1269
msgid "``\\f`` or ``\\x0c``"
msgstr ""

#: ../../library/stdtypes.rst:1269
msgid "Form Feed"
msgstr ""

#: ../../library/stdtypes.rst:1271
msgid "``\\x1c``"
msgstr ""

#: ../../library/stdtypes.rst:1271
msgid "File Separator"
msgstr ""

#: ../../library/stdtypes.rst:1273
msgid "``\\x1d``"
msgstr ""

#: ../../library/stdtypes.rst:1273
msgid "Group Separator"
msgstr ""

#: ../../library/stdtypes.rst:1275
msgid "``\\x1e``"
msgstr ""

#: ../../library/stdtypes.rst:1275
msgid "Record Separator"
msgstr ""

#: ../../library/stdtypes.rst:1277
msgid "``\\x85``"
msgstr ""

#: ../../library/stdtypes.rst:1277
msgid "Next Line (C1 Control Code)"
msgstr ""

#: ../../library/stdtypes.rst:1279
msgid "``\\u2028``"
msgstr ""

#: ../../library/stdtypes.rst:1279
msgid "Line Separator"
msgstr ""

#: ../../library/stdtypes.rst:1281
msgid "``\\u2029``"
msgstr ""

#: ../../library/stdtypes.rst:1281
msgid "Paragraph Separator"
msgstr ""

#: ../../library/stdtypes.rst:1286
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr ""

#: ../../library/stdtypes.rst:1291
msgid "Return ``True`` if string starts with the *prefix*, otherwise return ``False``. *prefix* can also be a tuple of prefixes to look for.  With optional *start*, test string beginning at that position.  With optional *end*, stop comparing string at that position."
msgstr ""

#: ../../library/stdtypes.rst:1296
msgid "Accept tuples as *prefix*."
msgstr ""

#: ../../library/stdtypes.rst:1302
msgid "Return a copy of the string with the leading and trailing characters removed. The *chars* argument is a string specifying the set of characters to be removed. If omitted or ``None``, the *chars* argument defaults to removing whitespace. The *chars* argument is not a prefix or suffix; rather, all combinations of its values are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1319
msgid "Return a copy of the string with uppercase characters converted to lowercase and vice versa."
msgstr ""

#: ../../library/stdtypes.rst:1327
msgid "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase."
msgstr ""

#: ../../library/stdtypes.rst:1330
msgid "The algorithm uses a simple language-independent definition of a word as groups of consecutive letters.  The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result::"
msgstr ""

#: ../../library/stdtypes.rst:1338
msgid "A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""

#: ../../library/stdtypes.rst:1355
msgid "Return a copy of the string where all characters occurring in the optional argument *deletechars* are removed, and the remaining characters have been mapped through the given translation table, which must be a string of length 256."
msgstr ""

#: ../../library/stdtypes.rst:1360
msgid "You can use the :func:`~string.maketrans` helper function in the :mod:`string` module to create a translation table. For string objects, set the *table* argument to ``None`` for translations that only delete characters:"
msgstr ""

#: ../../library/stdtypes.rst:1367
msgid "Support for a ``None`` *table* argument."
msgstr ""

#: ../../library/stdtypes.rst:1370
msgid "For Unicode objects, the :meth:`translate` method does not accept the optional *deletechars* argument.  Instead, it returns a copy of the *s* where all characters have been mapped through the given translation table which must be a mapping of Unicode ordinals to Unicode ordinals, Unicode strings or ``None``. Unmapped characters are left untouched. Characters mapped to ``None`` are deleted.  Note, a more flexible approach is to create a custom character mapping codec using the :mod:`codecs` module (see :mod:`encodings.cp1251` for an example)."
msgstr ""

#: ../../library/stdtypes.rst:1382
msgid "Return a copy of the string with all the cased characters [4]_ converted to uppercase.  Note that ``str.upper().isupper()`` might be ``False`` if ``s`` contains uncased characters or if the Unicode category of the resulting character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:1392
msgid "Return the numeric string left filled with zeros in a string of length *width*.  A sign prefix is handled correctly.  The original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1399
msgid "The following methods are present only on unicode objects:"
msgstr ""

#: ../../library/stdtypes.rst:1403
msgid "Return ``True`` if there are only numeric characters in S, ``False`` otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH."
msgstr ""

#: ../../library/stdtypes.rst:1410
msgid "Return ``True`` if there are only decimal characters in S, ``False`` otherwise. Decimal characters include digit characters, and all characters that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO."
msgstr ""

#: ../../library/stdtypes.rst:1419
msgid "String Formatting Operations"
msgstr ""

#: ../../library/stdtypes.rst:1431
msgid "String and Unicode objects have one unique built-in operation: the ``%`` operator (modulo).  This is also known as the string *formatting* or *interpolation* operator.  Given ``format % values`` (where *format* is a string or Unicode object), ``%`` conversion specifications in *format* are replaced with zero or more elements of *values*.  The effect is similar to the using :c:func:`sprintf` in the C language.  If *format* is a Unicode object, or if any of the objects being converted using the ``%s`` conversion are Unicode objects, the result will also be a Unicode object."
msgstr ""

#: ../../library/stdtypes.rst:1440
msgid "If *format* requires a single argument, *values* may be a single non-tuple object. [5]_  Otherwise, *values* must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary)."
msgstr ""

#: ../../library/stdtypes.rst:1445
msgid "A conversion specifier contains two or more characters and has the following components, which must occur in this order:"
msgstr ""

#: ../../library/stdtypes.rst:1448
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../library/stdtypes.rst:1450
msgid "Mapping key (optional), consisting of a parenthesised sequence of characters (for example, ``(somename)``)."
msgstr ""

#: ../../library/stdtypes.rst:1453
msgid "Conversion flags (optional), which affect the result of some conversion types."
msgstr ""

#: ../../library/stdtypes.rst:1456
msgid "Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the actual width is read from the next element of the tuple in *values*, and the object to convert comes after the minimum field width and optional precision."
msgstr ""

#: ../../library/stdtypes.rst:1460
msgid "Precision (optional), given as a ``'.'`` (dot) followed by the precision.  If specified as ``'*'`` (an asterisk), the actual width is read from the next element of the tuple in *values*, and the value to convert comes after the precision."
msgstr ""

#: ../../library/stdtypes.rst:1465
msgid "Length modifier (optional)."
msgstr ""

#: ../../library/stdtypes.rst:1467
msgid "Conversion type."
msgstr ""

#: ../../library/stdtypes.rst:1469
msgid "When the right argument is a dictionary (or other mapping type), then the formats in the string *must* include a parenthesised mapping key into that dictionary inserted immediately after the ``'%'`` character. The mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../library/stdtypes.rst:1478
msgid "In this case no ``*`` specifiers may occur in a format (since they require a sequential parameter list)."
msgstr ""

#: ../../library/stdtypes.rst:1481
msgid "The conversion flag characters are:"
msgstr ""

#: ../../library/stdtypes.rst:1484
msgid "Flag"
msgstr ""

#: ../../library/stdtypes.rst:1486
msgid "``'#'``"
msgstr ""

#: ../../library/stdtypes.rst:1486
msgid "The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: ../../library/stdtypes.rst:1489
msgid "``'0'``"
msgstr ""

#: ../../library/stdtypes.rst:1489
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../library/stdtypes.rst:1491
msgid "``'-'``"
msgstr ""

#: ../../library/stdtypes.rst:1491
msgid "The converted value is left adjusted (overrides the ``'0'`` conversion if both are given)."
msgstr ""

#: ../../library/stdtypes.rst:1494
msgid "``' '``"
msgstr ""

#: ../../library/stdtypes.rst:1494
msgid "(a space) A blank should be left before a positive number (or empty string) produced by a signed conversion."
msgstr ""

#: ../../library/stdtypes.rst:1497
msgid "``'+'``"
msgstr ""

#: ../../library/stdtypes.rst:1497
msgid "A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides a \"space\" flag)."
msgstr ""

#: ../../library/stdtypes.rst:1501
msgid "A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: ../../library/stdtypes.rst:1504
msgid "The conversion types are:"
msgstr ""

#: ../../library/stdtypes.rst:1507
msgid "Conversion"
msgstr ""

#: ../../library/stdtypes.rst:1509
msgid "``'d'``"
msgstr ""

#: ../../library/stdtypes.rst:1509
#: ../../library/stdtypes.rst:1511
msgid "Signed integer decimal."
msgstr ""

#: ../../library/stdtypes.rst:1511
msgid "``'i'``"
msgstr ""

#: ../../library/stdtypes.rst:1513
msgid "``'o'``"
msgstr ""

#: ../../library/stdtypes.rst:1513
msgid "Signed octal value."
msgstr ""

#: ../../library/stdtypes.rst:1515
msgid "``'u'``"
msgstr ""

#: ../../library/stdtypes.rst:1515
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: ../../library/stdtypes.rst:1517
msgid "``'x'``"
msgstr ""

#: ../../library/stdtypes.rst:1517
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:1519
msgid "``'X'``"
msgstr ""

#: ../../library/stdtypes.rst:1519
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:1521
msgid "``'e'``"
msgstr ""

#: ../../library/stdtypes.rst:1521
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:1523
msgid "``'E'``"
msgstr ""

#: ../../library/stdtypes.rst:1523
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:1525
msgid "``'f'``"
msgstr ""

#: ../../library/stdtypes.rst:1525
#: ../../library/stdtypes.rst:1527
msgid "Floating point decimal format."
msgstr ""

#: ../../library/stdtypes.rst:1527
msgid "``'F'``"
msgstr ""

#: ../../library/stdtypes.rst:1529
msgid "``'g'``"
msgstr ""

#: ../../library/stdtypes.rst:1529
msgid "Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1533
msgid "``'G'``"
msgstr ""

#: ../../library/stdtypes.rst:1533
msgid "Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1537
msgid "``'c'``"
msgstr ""

#: ../../library/stdtypes.rst:1537
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: ../../library/stdtypes.rst:1540
msgid "``'r'``"
msgstr ""

#: ../../library/stdtypes.rst:1540
msgid "String (converts any Python object using :ref:`repr() <func-repr>`)."
msgstr ""

#: ../../library/stdtypes.rst:1540
#: ../../library/stdtypes.rst:1689
msgid "\\(5)"
msgstr ""

#: ../../library/stdtypes.rst:1543
msgid "``'s'``"
msgstr ""

#: ../../library/stdtypes.rst:1543
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: ../../library/stdtypes.rst:1546
msgid "``'%'``"
msgstr ""

#: ../../library/stdtypes.rst:1546
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: ../../library/stdtypes.rst:1553
msgid "The alternate form causes a leading zero (``'0'``) to be inserted between left-hand padding and the formatting of the number if the leading character of the result is not already a zero."
msgstr ""

#: ../../library/stdtypes.rst:1558
msgid "The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on whether the ``'x'`` or ``'X'`` format was used) to be inserted before the first digit."
msgstr ""

#: ../../library/stdtypes.rst:1562
msgid "The alternate form causes the result to always contain a decimal point, even if no digits follow it."
msgstr ""

#: ../../library/stdtypes.rst:1565
msgid "The precision determines the number of digits after the decimal point and defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:1569
msgid "The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: ../../library/stdtypes.rst:1572
msgid "The precision determines the number of significant digits before and after the decimal point and defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:1576
msgid "The ``%r`` conversion was added in Python 2.0."
msgstr ""

#: ../../library/stdtypes.rst:1578
#: ../../library/stdtypes.rst:1584
msgid "The precision determines the maximal number of characters used."
msgstr ""

#: ../../library/stdtypes.rst:1581
msgid "If the object or format provided is a :class:`unicode` string, the resulting string will also be :class:`unicode`."
msgstr ""

#: ../../library/stdtypes.rst:1587
msgid "See :pep:`237`."
msgstr ""

#: ../../library/stdtypes.rst:1589
msgid "Since Python strings have an explicit length, ``%s`` conversions do not assume that ``'\\0'`` is the end of the string."
msgstr ""

#: ../../library/stdtypes.rst:1594
msgid "``%f`` conversions for numbers whose absolute value is over 1e50 are no longer replaced by ``%g`` conversions."
msgstr ""

#: ../../library/stdtypes.rst:1602
msgid "Additional string operations are defined in standard modules :mod:`string` and :mod:`re`."
msgstr ""

#: ../../library/stdtypes.rst:1609
msgid "XRange Type"
msgstr ""

#: ../../library/stdtypes.rst:1613
msgid "The :class:`xrange` type is an immutable sequence which is commonly used for looping.  The advantage of the :class:`xrange` type is that an :class:`xrange` object will always take the same amount of memory, no matter the size of the range it represents.  There are no consistent performance advantages."
msgstr ""

#: ../../library/stdtypes.rst:1618
msgid "XRange objects have very little behavior: they only support indexing, iteration, and the :func:`len` function."
msgstr ""

#: ../../library/stdtypes.rst:1625
msgid "Mutable Sequence Types"
msgstr ""

#: ../../library/stdtypes.rst:1631
msgid "List and :class:`bytearray` objects support additional operations that allow in-place modification of the object. Other mutable sequence types (when added to the language) should also support these operations. Strings and tuples are immutable sequence types: such objects cannot be modified once created. The following operations are defined on mutable sequence types (where *x* is an arbitrary object):"
msgstr ""

#: ../../library/stdtypes.rst:1658
msgid "``s[i] = x``"
msgstr ""

#: ../../library/stdtypes.rst:1658
msgid "item *i* of *s* is replaced by *x*"
msgstr ""

#: ../../library/stdtypes.rst:1661
msgid "``s[i:j] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1661
msgid "slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""

#: ../../library/stdtypes.rst:1665
msgid "``del s[i:j]``"
msgstr ""

#: ../../library/stdtypes.rst:1665
msgid "same as ``s[i:j] = []``"
msgstr ""

#: ../../library/stdtypes.rst:1667
msgid "``s[i:j:k] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1667
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""

#: ../../library/stdtypes.rst:1670
msgid "``del s[i:j:k]``"
msgstr ""

#: ../../library/stdtypes.rst:1670
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr ""

#: ../../library/stdtypes.rst:1673
msgid "``s.append(x)``"
msgstr ""

#: ../../library/stdtypes.rst:1673
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr ""

#: ../../library/stdtypes.rst:1676
msgid "``s.extend(t)`` or ``s += t``"
msgstr ""

#: ../../library/stdtypes.rst:1676
msgid "for the most part the same as ``s[len(s):len(s)] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1679
msgid "``s *= n``"
msgstr ""

#: ../../library/stdtypes.rst:1679
msgid "updates *s* with its contents repeated *n* times"
msgstr ""

#: ../../library/stdtypes.rst:1679
msgid "\\(11)"
msgstr ""

#: ../../library/stdtypes.rst:1682
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr ""

#: ../../library/stdtypes.rst:1685
msgid "``s.index(x[, i[, j]])``"
msgstr ""

#: ../../library/stdtypes.rst:1685
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr ""

#: ../../library/stdtypes.rst:1689
msgid "``s.insert(i, x)``"
msgstr ""

#: ../../library/stdtypes.rst:1689
msgid "same as ``s[i:i] = [x]``"
msgstr ""

#: ../../library/stdtypes.rst:1691
msgid "``s.pop([i])``"
msgstr ""

#: ../../library/stdtypes.rst:1691
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr ""

#: ../../library/stdtypes.rst:1694
msgid "``s.remove(x)``"
msgstr ""

#: ../../library/stdtypes.rst:1694
msgid "same as ``del s[s.index(x)]``"
msgstr ""

#: ../../library/stdtypes.rst:1696
msgid "``s.reverse()``"
msgstr ""

#: ../../library/stdtypes.rst:1696
msgid "reverses the items of *s* in place"
msgstr ""

#: ../../library/stdtypes.rst:1699
msgid "``s.sort([cmp[, key[, reverse]]])``"
msgstr ""

#: ../../library/stdtypes.rst:1699
msgid "sort the items of *s* in place"
msgstr ""

#: ../../library/stdtypes.rst:1699
msgid "(7)(8)(9)(10)"
msgstr ""

#: ../../library/stdtypes.rst:1706
msgid "*t* must have the same length as the slice it is  replacing."
msgstr ""

#: ../../library/stdtypes.rst:1709
msgid "The C implementation of Python has historically accepted multiple parameters and implicitly joined them into a tuple; this no longer works in Python 2.0.  Use of this misfeature has been deprecated since Python 1.4."
msgstr ""

#: ../../library/stdtypes.rst:1714
msgid "*t* can be any iterable object."
msgstr ""

#: ../../library/stdtypes.rst:1717
msgid "Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index is passed as the second or third parameter to the :meth:`index` method, the list length is added, as for slice indices.  If it is still negative, it is truncated to zero, as for slice indices."
msgstr ""

#: ../../library/stdtypes.rst:1722
msgid "Previously, :meth:`index` didn't have arguments for specifying start and stop positions."
msgstr ""

#: ../../library/stdtypes.rst:1727
msgid "When a negative index is passed as the first parameter to the :meth:`insert` method, the list length is added, as for slice indices.  If it is still negative, it is truncated to zero, as for slice indices."
msgstr ""

#: ../../library/stdtypes.rst:1731
msgid "Previously, all negative indices were truncated to zero."
msgstr ""

#: ../../library/stdtypes.rst:1735
msgid "The :meth:`pop` method's optional argument *i* defaults to ``-1``, so that by default the last item is removed and returned."
msgstr ""

#: ../../library/stdtypes.rst:1739
msgid "The :meth:`sort` and :meth:`reverse` methods modify the list in place for economy of space when sorting or reversing a large list.  To remind you that they operate by side effect, they don't return the sorted or reversed list."
msgstr ""

#: ../../library/stdtypes.rst:1744
msgid "The :meth:`sort` method takes optional arguments for controlling the comparisons."
msgstr ""

#: ../../library/stdtypes.rst:1747
msgid "*cmp* specifies a custom comparison function of two arguments (list items) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: ``cmp=lambda x,y: cmp(x.lower(), y.lower())``.  The default value is ``None``."
msgstr ""

#: ../../library/stdtypes.rst:1753
msgid "*key* specifies a function of one argument that is used to extract a comparison key from each list element: ``key=str.lower``.  The default value is ``None``."
msgstr ""

#: ../../library/stdtypes.rst:1756
msgid "*reverse* is a boolean value.  If set to ``True``, then the list elements are sorted as if each comparison were reversed."
msgstr ""

#: ../../library/stdtypes.rst:1759
msgid "In general, the *key* and *reverse* conversion processes are much faster than specifying an equivalent *cmp* function.  This is because *cmp* is called multiple times for each list element while *key* and *reverse* touch each element only once.  Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a *key* function."
msgstr ""

#: ../../library/stdtypes.rst:1765
msgid "Support for ``None`` as an equivalent to omitting *cmp* was added."
msgstr ""

#: ../../library/stdtypes.rst:1768
msgid "Support for *key* and *reverse* was added."
msgstr ""

#: ../../library/stdtypes.rst:1772
msgid "Starting with Python 2.3, the :meth:`sort` method is guaranteed to be stable.  A sort is stable if it guarantees not to change the relative order of elements that compare equal --- this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade)."
msgstr ""

#: ../../library/stdtypes.rst:1780
msgid "While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined.  The C implementation of Python 2.3 and newer makes the list appear empty for the duration, and raises :exc:`ValueError` if it can detect that the list has been mutated during a sort."
msgstr ""

#: ../../library/stdtypes.rst:1787
msgid "The value *n* is an integer, or an object implementing :meth:`~object.__index__`.  Zero and negative values of *n* clear the sequence.  Items in the sequence are not copied; they are referenced multiple times, as explained for ``s * n`` under :ref:`typesseq`."
msgstr ""

#: ../../library/stdtypes.rst:1796
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr ""

#: ../../library/stdtypes.rst:1800
msgid "A :dfn:`set` object is an unordered collection of distinct :term:`hashable` objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. (For other containers see the built in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:1810
msgid "Like other collections, sets support ``x in set``, ``len(set)``, and ``for x in set``.  Being an unordered collection, sets do not record element position or order of insertion.  Accordingly, sets do not support indexing, slicing, or other sequence-like behavior."
msgstr ""

#: ../../library/stdtypes.rst:1815
msgid "There are currently two built-in set types, :class:`set` and :class:`frozenset`. The :class:`set` type is mutable --- the contents can be changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.  The :class:`frozenset` type is immutable and :term:`hashable` --- its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set."
msgstr ""

#: ../../library/stdtypes.rst:1823
msgid "As of Python 2.7, non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in addition to the :class:`set` constructor."
msgstr ""

#: ../../library/stdtypes.rst:1827
msgid "The constructors for both classes work the same:"
msgstr ""

#: ../../library/stdtypes.rst:1832
msgid "Return a new set or frozenset object whose elements are taken from *iterable*.  The elements of a set must be :term:`hashable`.  To represent sets of sets, the inner sets must be :class:`frozenset` objects.  If *iterable* is not specified, a new empty set is returned."
msgstr ""

#: ../../library/stdtypes.rst:1838
msgid "Instances of :class:`set` and :class:`frozenset` provide the following operations:"
msgstr ""

#: ../../library/stdtypes.rst:1843
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""

#: ../../library/stdtypes.rst:1847
msgid "Test *x* for membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:1851
msgid "Test *x* for non-membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:1855
msgid "Return ``True`` if the set has no elements in common with *other*.  Sets are disjoint if and only if their intersection is the empty set."
msgstr ""

#: ../../library/stdtypes.rst:1863
msgid "Test whether every element in the set is in *other*."
msgstr ""

#: ../../library/stdtypes.rst:1867
msgid "Test whether the set is a proper subset of *other*, that is, ``set <= other and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:1873
msgid "Test whether every element in *other* is in the set."
msgstr ""

#: ../../library/stdtypes.rst:1877
msgid "Test whether the set is a proper superset of *other*, that is, ``set >= other and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:1883
msgid "Return a new set with elements from the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:1885
#: ../../library/stdtypes.rst:1893
#: ../../library/stdtypes.rst:1901
#: ../../library/stdtypes.rst:1955
#: ../../library/stdtypes.rst:1963
#: ../../library/stdtypes.rst:1971
msgid "Accepts multiple input iterables."
msgstr ""

#: ../../library/stdtypes.rst:1891
msgid "Return a new set with elements common to the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:1899
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""

#: ../../library/stdtypes.rst:1907
msgid "Return a new set with elements in either the set or *other* but not both."
msgstr ""

#: ../../library/stdtypes.rst:1911
msgid "Return a new set with a shallow copy of *s*."
msgstr ""

#: ../../library/stdtypes.rst:1914
msgid "Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :meth:`issuperset` methods will accept any iterable as an argument.  In contrast, their operator based counterparts require their arguments to be sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/stdtypes.rst:1921
msgid "Both :class:`set` and :class:`frozenset` support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""

#: ../../library/stdtypes.rst:1928
msgid "Instances of :class:`set` are compared to instances of :class:`frozenset` based on their members.  For example, ``set('abc') == frozenset('abc')`` returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""

#: ../../library/stdtypes.rst:1932
msgid "The subset and equality comparisons do not generalize to a total ordering function.  For example, any two non-empty disjoint sets are not equal and are not subsets of each other, so *all* of the following return ``False``: ``a<b``, ``a==b``, or ``a>b``. Accordingly, sets do not implement the :meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:1938
msgid "Since sets only define partial ordering (subset relationships), the output of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../library/stdtypes.rst:1941
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""

#: ../../library/stdtypes.rst:1943
msgid "Binary operations that mix :class:`set` instances with :class:`frozenset` return the type of the first operand.  For example: ``frozenset('ab') | set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""

#: ../../library/stdtypes.rst:1947
msgid "The following table lists operations available for :class:`set` that do not apply to immutable instances of :class:`frozenset`:"
msgstr ""

#: ../../library/stdtypes.rst:1953
msgid "Update the set, adding elements from all others."
msgstr ""

#: ../../library/stdtypes.rst:1961
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""

#: ../../library/stdtypes.rst:1969
msgid "Update the set, removing elements found in others."
msgstr ""

#: ../../library/stdtypes.rst:1977
msgid "Update the set, keeping only elements found in either set, but not in both."
msgstr ""

#: ../../library/stdtypes.rst:1981
msgid "Add element *elem* to the set."
msgstr ""

#: ../../library/stdtypes.rst:1985
msgid "Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not contained in the set."
msgstr ""

#: ../../library/stdtypes.rst:1990
msgid "Remove element *elem* from the set if it is present."
msgstr ""

#: ../../library/stdtypes.rst:1994
msgid "Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` if the set is empty."
msgstr ""

#: ../../library/stdtypes.rst:1999
msgid "Remove all elements from the set."
msgstr ""

#: ../../library/stdtypes.rst:2002
msgid "Note, the non-operator versions of the :meth:`update`, :meth:`intersection_update`, :meth:`difference_update`, and :meth:`symmetric_difference_update` methods will accept any iterable as an argument."
msgstr ""

#: ../../library/stdtypes.rst:2007
msgid "Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :meth:`discard` methods may be a set.  To support searching for an equivalent frozenset, a temporary one is created from *elem*."
msgstr ""

#: ../../library/stdtypes.rst:2014
msgid ":ref:`comparison-to-builtin-set`"
msgstr ""

#: ../../library/stdtypes.rst:2015
msgid "Differences between the :mod:`sets` module and the built-in set types."
msgstr ""

#: ../../library/stdtypes.rst:2021
msgid "Mapping Types --- :class:`dict`"
msgstr ""

#: ../../library/stdtypes.rst:2031
msgid "A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. Mappings are mutable objects.  There is currently only one standard mapping type, the :dfn:`dictionary`.  (For other containers see the built in :class:`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:2037
msgid "A dictionary's keys are *almost* arbitrary values.  Values that are not :term:`hashable`, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys.  Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as ``1`` and ``1.0``) then they can be used interchangeably to index the same dictionary entry.  (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""

#: ../../library/stdtypes.rst:2046
msgid "Dictionaries can be created by placing a comma-separated list of ``key: value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""

#: ../../library/stdtypes.rst:2054
msgid "Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:2057
msgid "If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object.  Otherwise, the positional argument must be an :term:`iterable` object.  Each item in the iterable must itself be an iterable with exactly two objects.  The first object of each item becomes a key in the new dictionary, and the second object the corresponding value.  If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2067
msgid "If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument.  If a key being added is already present, the value from the keyword argument replaces the value from the positional argument."
msgstr ""

#: ../../library/stdtypes.rst:2072
msgid "To illustrate, the following examples all return a dictionary equal to ``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""

#: ../../library/stdtypes.rst:2083
msgid "Providing keyword arguments as in the first example only works for keys that are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""

#: ../../library/stdtypes.rst:2088
msgid "Support for building a dictionary from keyword arguments added."
msgstr ""

#: ../../library/stdtypes.rst:2092
msgid "These are the operations that dictionaries support (and therefore, custom mapping types should support too):"
msgstr ""

#: ../../library/stdtypes.rst:2097
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: ../../library/stdtypes.rst:2101
msgid "Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is not in the map."
msgstr ""

#: ../../library/stdtypes.rst:2106
msgid "If a subclass of dict defines a method :meth:`__missing__` and *key* is not present, the ``d[key]`` operation calls that method with the key *key* as argument.  The ``d[key]`` operation then returns or raises whatever is returned or raised by the ``__missing__(key)`` call. No other operations or methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be an instance variable::"
msgstr ""

#: ../../library/stdtypes.rst:2124
msgid "The example above shows part of the implementation of :class:`collections.Counter`.  A different ``__missing__`` method is used by :class:`collections.defaultdict`."
msgstr ""

#: ../../library/stdtypes.rst:2128
msgid "Recognition of __missing__ methods of dict subclasses."
msgstr ""

#: ../../library/stdtypes.rst:2133
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: ../../library/stdtypes.rst:2137
msgid "Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the map."
msgstr ""

#: ../../library/stdtypes.rst:2142
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: ../../library/stdtypes.rst:2148
msgid "Equivalent to ``not key in d``."
msgstr ""

#: ../../library/stdtypes.rst:2154
msgid "Return an iterator over the keys of the dictionary.  This is a shortcut for :meth:`iterkeys`."
msgstr ""

#: ../../library/stdtypes.rst:2159
msgid "Remove all items from the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2163
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2167
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""

#: ../../library/stdtypes.rst:2169
msgid ":func:`fromkeys` is a class method that returns a new dictionary. *value* defaults to ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2176
msgid "Return the value for *key* if *key* is in the dictionary, else *default*. If *default* is not given, it defaults to ``None``, so that this method never raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:2182
msgid "Test for the presence of *key* in the dictionary.  :meth:`has_key` is deprecated in favor of ``key in d``."
msgstr ""

#: ../../library/stdtypes.rst:2187
msgid "Return a copy of the dictionary's list of ``(key, value)`` pairs."
msgstr ""

#: ../../library/stdtypes.rst:2191
msgid "Keys and values are listed in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionary's history of insertions and deletions."
msgstr ""

#: ../../library/stdtypes.rst:2195
msgid "If :meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, :meth:`iterkeys`, and :meth:`itervalues` are called with no intervening modifications to the dictionary, the lists will directly correspond.  This allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  The same relationship holds for the :meth:`iterkeys` and :meth:`itervalues` methods: ``pairs = zip(d.itervalues(), d.iterkeys())`` provides the same value for ``pairs``. Another way to create the same list is ``pairs = [(v, k) for (k, v) in d.iteritems()]``."
msgstr ""

#: ../../library/stdtypes.rst:2207
msgid "Return an iterator over the dictionary's ``(key, value)`` pairs.  See the note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2210
msgid "Using :meth:`iteritems` while adding or deleting entries in the dictionary may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2217
msgid "Return an iterator over the dictionary's keys.  See the note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2220
msgid "Using :meth:`iterkeys` while adding or deleting entries in the dictionary may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2227
msgid "Return an iterator over the dictionary's values.  See the note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2230
msgid "Using :meth:`itervalues` while adding or deleting entries in the dictionary may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2238
msgid "Return a copy of the dictionary's list of keys.  See the note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2243
msgid "If *key* is in the dictionary, remove it and return its value, else return *default*.  If *default* is not given and *key* is not in the dictionary, a :exc:`KeyError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:2251
msgid "Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2253
msgid ":func:`popitem` is useful to destructively iterate over a dictionary, as often used in set algorithms.  If the dictionary is empty, calling :func:`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:2259
msgid "If *key* is in the dictionary, return its value.  If not, insert *key* with a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2265
msgid "Update the dictionary with the key/value pairs from *other*, overwriting existing keys.  Return ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2268
msgid ":func:`update` accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two).  If keyword arguments are specified, the dictionary is then updated with those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../library/stdtypes.rst:2273
msgid "Allowed the argument to be an iterable of key/value pairs and allowed keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:2279
msgid "Return a copy of the dictionary's list of values.  See the note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2284
msgid "Return a new view of the dictionary's items (``(key, value)`` pairs).  See below for documentation of view objects."
msgstr ""

#: ../../library/stdtypes.rst:2291
msgid "Return a new view of the dictionary's keys.  See below for documentation of view objects."
msgstr ""

#: ../../library/stdtypes.rst:2298
msgid "Return a new view of the dictionary's values.  See below for documentation of view objects."
msgstr ""

#: ../../library/stdtypes.rst:2303
msgid "Dictionaries compare equal if and only if they have the same ``(key, value)`` pairs."
msgstr ""

#: ../../library/stdtypes.rst:2310
msgid "Dictionary view objects"
msgstr ""

#: ../../library/stdtypes.rst:2312
msgid "The objects returned by :meth:`dict.viewkeys`, :meth:`dict.viewvalues` and :meth:`dict.viewitems` are *view objects*.  They provide a dynamic view on the dictionary's entries, which means that when the dictionary changes, the view reflects these changes."
msgstr ""

#: ../../library/stdtypes.rst:2317
msgid "Dictionary views can be iterated over to yield their respective data, and support membership tests:"
msgstr ""

#: ../../library/stdtypes.rst:2322
msgid "Return the number of entries in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2326
msgid "Return an iterator over the keys, values or items (represented as tuples of ``(key, value)``) in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2329
msgid "Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionary's history of insertions and deletions. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.  This allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  Another way to create the same list is ``pairs = [(v, k) for (k, v) in d.items()]``."
msgstr ""

#: ../../library/stdtypes.rst:2337
msgid "Iterating views while adding or deleting entries in the dictionary may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2342
msgid "Return ``True`` if *x* is in the underlying dictionary's keys, values or items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""

#: ../../library/stdtypes.rst:2346
msgid "Keys views are set-like since their entries are unique and hashable.  If all values are hashable, so that (key, value) pairs are unique and hashable, then the items view is also set-like.  (Values views are not treated as set-like since the entries are generally not unique.)  Then these set operations are available (\"other\" refers either to another view or a set):"
msgstr ""

#: ../../library/stdtypes.rst:2354
msgid "Return the intersection of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2358
msgid "Return the union of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2362
msgid "Return the difference between the dictview and the other object (all elements in *dictview* that aren't in *other*) as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2367
msgid "Return the symmetric difference (all elements either in *dictview* or *other*, but not in both) of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2371
msgid "An example of dictionary view usage::"
msgstr ""

#: ../../library/stdtypes.rst:2404
msgid "File Objects"
msgstr ""

#: ../../library/stdtypes.rst:2412
msgid "File objects are implemented using C's ``stdio`` package and can be created with the built-in :func:`open` function.  File objects are also returned by some other built-in functions and methods, such as :func:`os.popen` and :func:`os.fdopen` and the :meth:`makefile` method of socket objects. Temporary files can be created using the :mod:`tempfile` module, and high-level file operations such as copying, moving, and deleting files and directories can be achieved with the :mod:`shutil` module."
msgstr ""

#: ../../library/stdtypes.rst:2421
msgid "When a file operation fails for an I/O-related reason, the exception :exc:`IOError` is raised.  This includes situations where the operation is not defined for some reason, like :meth:`seek` on a tty device or writing a file opened for reading."
msgstr ""

#: ../../library/stdtypes.rst:2426
msgid "Files have the following methods:"
msgstr ""

#: ../../library/stdtypes.rst:2431
msgid "Close the file.  A closed file cannot be read or written any more. Any operation which requires that the file be open will raise a :exc:`ValueError` after the file has been closed.  Calling :meth:`close` more than once is allowed."
msgstr ""

#: ../../library/stdtypes.rst:2435
msgid "As of Python 2.5, you can avoid having to call this method explicitly if you use the :keyword:`with` statement.  For example, the following code will automatically close *f* when the :keyword:`with` block is exited::"
msgstr ""

#: ../../library/stdtypes.rst:2445
msgid "In older versions of Python, you would have needed to do this to get the same effect::"
msgstr ""

#: ../../library/stdtypes.rst:2457
msgid "Not all \"file-like\" types in Python support use as a context manager for the :keyword:`with` statement.  If your code is intended to work with any file-like object, you can use the function :func:`contextlib.closing` instead of using the object directly."
msgstr ""

#: ../../library/stdtypes.rst:2465
msgid "Flush the internal buffer, like ``stdio``'s :c:func:`fflush`.  This may be a no-op on some file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2470
msgid ":meth:`flush` does not necessarily write the file's data to disk.  Use :meth:`flush` followed by :func:`os.fsync` to ensure this behavior."
msgstr ""

#: ../../library/stdtypes.rst:2480
msgid "Return the integer \"file descriptor\" that is used by the underlying implementation to request I/O operations from the operating system.  This can be useful for other, lower level interfaces that use file descriptors, such as the :mod:`fcntl` module or :func:`os.read` and friends."
msgstr ""

#: ../../library/stdtypes.rst:2487
msgid "File-like objects which do not have a real file descriptor should *not* provide this method!"
msgstr ""

#: ../../library/stdtypes.rst:2493
msgid "Return ``True`` if the file is connected to a tty(-like) device, else ``False``."
msgstr ""

#: ../../library/stdtypes.rst:2497
msgid "If a file-like object is not associated with a real file, this method should *not* be implemented."
msgstr ""

#: ../../library/stdtypes.rst:2503
msgid "A file object is its own iterator, for example ``iter(f)`` returns *f* (unless *f* is closed).  When a file is used as an iterator, typically in a :keyword:`for` loop (for example, ``for line in f: print line.strip()``), the :meth:`~file.next` method is called repeatedly.  This method returns the next input line, or raises :exc:`StopIteration` when EOF is hit when the file is open for reading (behavior is undefined when the file is open for writing).  In order to make a :keyword:`for` loop the most efficient way of looping over the lines of a file (a very common operation), the :meth:`~file.next` method uses a hidden read-ahead buffer.  As a consequence of using a read-ahead buffer, combining :meth:`~file.next` with other file methods (like :meth:`~file.readline`) does not work right.  However, using :meth:`seek` to reposition the file to an absolute position will flush the read-ahead buffer."
msgstr ""

#: ../../library/stdtypes.rst:2521
msgid "Read at most *size* bytes from the file (less if the read hits EOF before obtaining *size* bytes).  If the *size* argument is negative or omitted, read all data until EOF is reached.  The bytes are returned as a string object.  An empty string is returned when EOF is encountered immediately.  (For certain files, like ttys, it makes sense to continue reading after an EOF is hit.)  Note that this method may call the underlying C function :c:func:`fread` more than once in an effort to acquire as close to *size* bytes as possible. Also note that when in non-blocking mode, less data than was requested may be returned, even if no *size* parameter was given."
msgstr ""

#: ../../library/stdtypes.rst:2532
msgid "This function is simply a wrapper for the underlying :c:func:`fread` C function, and will behave the same in corner cases, such as whether the EOF value is cached."
msgstr ""

#: ../../library/stdtypes.rst:2539
msgid "Read one entire line from the file.  A trailing newline character is kept in the string (but may be absent when a file ends with an incomplete line). [6]_ If the *size* argument is present and non-negative, it is a maximum byte count (including the trailing newline) and an incomplete line may be returned. When *size* is not 0, an empty string is returned *only* when EOF is encountered immediately."
msgstr ""

#: ../../library/stdtypes.rst:2548
msgid "Unlike ``stdio``'s :c:func:`fgets`, the returned string contains null characters (``'\\0'``) if they occurred in the input."
msgstr ""

#: ../../library/stdtypes.rst:2554
msgid "Read until EOF using :meth:`~file.readline` and return a list containing the lines thus read.  If the optional *sizehint* argument is present, instead of reading up to EOF, whole lines totalling approximately *sizehint* bytes (possibly after rounding up to an internal buffer size) are read.  Objects implementing a file-like interface may choose to ignore *sizehint* if it cannot be implemented, or cannot be implemented efficiently."
msgstr ""

#: ../../library/stdtypes.rst:2564
msgid "This method returns the same thing as ``iter(f)``."
msgstr ""

#: ../../library/stdtypes.rst:2568
msgid "Use ``for line in file`` instead."
msgstr ""

#: ../../library/stdtypes.rst:2574
msgid "Set the file's current position, like ``stdio``'s :c:func:`fseek`. The *whence* argument is optional and defaults to  ``os.SEEK_SET`` or ``0`` (absolute file positioning); other values are ``os.SEEK_CUR`` or ``1`` (seek relative to the current position) and ``os.SEEK_END`` or ``2``  (seek relative to the file's end).  There is no return value."
msgstr ""

#: ../../library/stdtypes.rst:2580
msgid "For example, ``f.seek(2, os.SEEK_CUR)`` advances the position by two and ``f.seek(-3, os.SEEK_END)`` sets the position to the third to last."
msgstr ""

#: ../../library/stdtypes.rst:2583
msgid "Note that if the file is opened for appending (mode ``'a'`` or ``'a+'``), any :meth:`seek` operations will be undone at the next write.  If the file is only opened for writing in append mode (mode ``'a'``), this method is essentially a no-op, but it remains useful for files opened in append mode with reading enabled (mode ``'a+'``).  If the file is opened in text mode (without ``'b'``), only offsets returned by :meth:`tell` are legal.  Use of other offsets causes undefined behavior."
msgstr ""

#: ../../library/stdtypes.rst:2591
msgid "Note that not all file objects are seekable."
msgstr ""

#: ../../library/stdtypes.rst:2593
msgid "Passing float values as offset has been deprecated."
msgstr ""

#: ../../library/stdtypes.rst:2599
msgid "Return the file's current position, like ``stdio``'s :c:func:`ftell`."
msgstr ""

#: ../../library/stdtypes.rst:2603
msgid "On Windows, :meth:`tell` can return illegal values (after an :c:func:`fgets`) when reading files with Unix-style line-endings. Use binary mode (``'rb'``) to circumvent this problem."
msgstr ""

#: ../../library/stdtypes.rst:2610
msgid "Truncate the file's size.  If the optional *size* argument is present, the file is truncated to (at most) that size.  The size defaults to the current position. The current file position is not changed.  Note that if a specified size exceeds the file's current size, the result is platform-dependent:  possibilities include that the file may remain unchanged, increase to the specified size as if zero-filled, or increase to the specified size with undefined new content. Availability:  Windows, many Unix variants."
msgstr ""

#: ../../library/stdtypes.rst:2621
msgid "Write a string to the file.  There is no return value.  Due to buffering, the string may not actually show up in the file until the :meth:`flush` or :meth:`close` method is called."
msgstr ""

#: ../../library/stdtypes.rst:2628
msgid "Write a sequence of strings to the file.  The sequence can be any iterable object producing strings, typically a list of strings. There is no return value. (The name is intended to match :meth:`readlines`; :meth:`writelines` does not add line separators.)"
msgstr ""

#: ../../library/stdtypes.rst:2633
msgid "Files support the iterator protocol.  Each iteration returns the same result as :meth:`~file.readline`, and iteration ends when the :meth:`~file.readline` method returns an empty string."
msgstr ""

#: ../../library/stdtypes.rst:2637
msgid "File objects also offer a number of other interesting attributes. These are not required for file-like objects, but should be implemented if they make sense for the particular object."
msgstr ""

#: ../../library/stdtypes.rst:2644
msgid "bool indicating the current state of the file object.  This is a read-only attribute; the :meth:`close` method changes the value. It may not be available on all file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2651
msgid "The encoding that this file uses. When Unicode strings are written to a file, they will be converted to byte strings using this encoding. In addition, when the file is connected to a terminal, the attribute gives the encoding that the terminal is likely to use (that  information might be incorrect if the user has misconfigured the  terminal). The attribute is read-only and may not be present on all file-like objects. It may also be ``None``, in which case the file uses the system default encoding for converting Unicode strings."
msgstr ""

#: ../../library/stdtypes.rst:2664
msgid "The Unicode error handler used along with the encoding."
msgstr ""

#: ../../library/stdtypes.rst:2671
msgid "The I/O mode for the file.  If the file was created using the :func:`open` built-in function, this will be the value of the *mode* parameter.  This is a read-only attribute and may not be present on all file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2678
msgid "If the file object was created using :func:`open`, the name of the file. Otherwise, some string that indicates the source of the file object, of the form ``<...>``.  This is a read-only attribute and may not be present on all file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2689
msgid "If Python was built with :term:`universal newlines` enabled (the default) this read-only attribute exists, and for files opened in universal newline read mode it keeps track of the types of newlines encountered while reading the file. The values it can take are ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, ``None`` (unknown, no newlines read yet) or a tuple containing all the newline types seen, to indicate that multiple newline conventions were encountered. For files not opened in universal newlines read mode the value of this attribute will be ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2701
msgid "Boolean that indicates whether a space character needs to be printed before another value when using the :keyword:`print` statement. Classes that are trying to simulate a file object should also have a writable :attr:`softspace` attribute, which should be initialized to zero.  This will be automatic for most classes implemented in Python (care may be needed for objects that override attribute access); types implemented in C will have to provide a writable :attr:`softspace` attribute."
msgstr ""

#: ../../library/stdtypes.rst:2711
msgid "This attribute is not used to control the :keyword:`print` statement, but to allow the implementation of :keyword:`print` to keep track of its internal state."
msgstr ""

#: ../../library/stdtypes.rst:2719
msgid "memoryview type"
msgstr ""

#: ../../library/stdtypes.rst:2723
msgid ":class:`memoryview` objects allow Python code to access the internal data of an object that supports the buffer protocol without copying.  Memory is generally interpreted as simple bytes."
msgstr ""

#: ../../library/stdtypes.rst:2729
msgid "Create a :class:`memoryview` that references *obj*.  *obj* must support the buffer protocol.  Built-in objects that support the buffer protocol include :class:`str` and :class:`bytearray` (but not :class:`unicode`)."
msgstr ""

#: ../../library/stdtypes.rst:2733
msgid "A :class:`memoryview` has the notion of an *element*, which is the atomic memory unit handled by the originating object *obj*.  For many simple types such as :class:`str` and :class:`bytearray`, an element is a single byte, but other third-party types may expose larger elements."
msgstr ""

#: ../../library/stdtypes.rst:2738
msgid "``len(view)`` returns the total number of elements in the memoryview, *view*.  The :class:`~memoryview.itemsize` attribute will give you the number of bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:2742
msgid "A :class:`memoryview` supports slicing to expose its data.  Taking a single index will return a single element as a :class:`str` object.  Full slicing will result in a subview::"
msgstr ""

#: ../../library/stdtypes.rst:2756
msgid "If the object the memoryview is over supports changing its data, the memoryview supports slice assignment::"
msgstr ""

#: ../../library/stdtypes.rst:2774
msgid "Notice how the size of the memoryview object cannot be changed."
msgstr ""

#: ../../library/stdtypes.rst:2776
msgid ":class:`memoryview` has two methods:"
msgstr ""

#: ../../library/stdtypes.rst:2780
msgid "Return the data in the buffer as a bytestring (an object of class :class:`str`). ::"
msgstr ""

#: ../../library/stdtypes.rst:2789
msgid "Return the data in the buffer as a list of integers. ::"
msgstr ""

#: ../../library/stdtypes.rst:2794
msgid "There are also several readonly attributes available:"
msgstr ""

#: ../../library/stdtypes.rst:2798
msgid "A string containing the format (in :mod:`struct` module style) for each element in the view.  This defaults to ``'B'``, a simple bytestring."
msgstr ""

#: ../../library/stdtypes.rst:2803
msgid "The size in bytes of each element of the memoryview."
msgstr ""

#: ../../library/stdtypes.rst:2807
msgid "A tuple of integers the length of :attr:`ndim` giving the shape of the memory as an N-dimensional array."
msgstr ""

#: ../../library/stdtypes.rst:2812
msgid "An integer indicating how many dimensions of a multi-dimensional array the memory represents."
msgstr ""

#: ../../library/stdtypes.rst:2817
msgid "A tuple of integers the length of :attr:`ndim` giving the size in bytes to access each element for each dimension of the array."
msgstr ""

#: ../../library/stdtypes.rst:2822
msgid "A bool indicating whether the memory is read only."
msgstr ""

#: ../../library/stdtypes.rst:2830
msgid "Context Manager Types"
msgstr ""

#: ../../library/stdtypes.rst:2839
msgid "Python's :keyword:`with` statement supports the concept of a runtime context defined by a context manager.  This is implemented using two separate methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends."
msgstr ""

#: ../../library/stdtypes.rst:2844
msgid "The :dfn:`context management protocol` consists of a pair of methods that need to be provided for a context manager object to define a runtime context:"
msgstr ""

#: ../../library/stdtypes.rst:2850
msgid "Enter the runtime context and return either this object or another object related to the runtime context. The value returned by this method is bound to the identifier in the :keyword:`as` clause of :keyword:`with` statements using this context manager."
msgstr ""

#: ../../library/stdtypes.rst:2855
msgid "An example of a context manager that returns itself is a file object. File objects return themselves from __enter__() to allow :func:`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2859
msgid "An example of a context manager that returns a related object is the one returned by :func:`decimal.localcontext`. These managers set the active decimal context to a copy of the original decimal context and then return the copy. This allows changes to be made to the current decimal context in the body of the :keyword:`with` statement without affecting code outside the :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2869
msgid "Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed. If an exception occurred while executing the body of the :keyword:`with` statement, the arguments contain the exception type, value and traceback information. Otherwise, all three arguments are ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2874
msgid "Returning a true value from this method will cause the :keyword:`with` statement to suppress the exception and continue execution with the statement immediately following the :keyword:`with` statement. Otherwise the exception continues propagating after this method has finished executing. Exceptions that occur during execution of this method will replace any exception that occurred in the body of the :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2881
msgid "The exception passed in should never be reraised explicitly - instead, this method should return a false value to indicate that the method completed successfully and does not want to suppress the raised exception. This allows context management code (such as ``contextlib.nested``) to easily detect whether or not an :meth:`__exit__` method has actually failed."
msgstr ""

#: ../../library/stdtypes.rst:2887
msgid "Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context. The specific types are not treated specially beyond their implementation of the context management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""

#: ../../library/stdtypes.rst:2893
msgid "Python's :term:`generator`\\s and the ``contextlib.contextmanager`` :term:`decorator` provide a convenient way to implement these protocols.  If a generator function is decorated with the ``contextlib.contextmanager`` decorator, it will return a context manager implementing the necessary :meth:`__enter__` and :meth:`__exit__` methods, rather than the iterator produced by an undecorated generator function."
msgstr ""

#: ../../library/stdtypes.rst:2900
msgid "Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible."
msgstr ""

#: ../../library/stdtypes.rst:2910
msgid "Other Built-in Types"
msgstr ""

#: ../../library/stdtypes.rst:2912
msgid "The interpreter supports several other kinds of objects. Most of these support only one or two operations."
msgstr ""

#: ../../library/stdtypes.rst:2919
msgid "Modules"
msgstr ""

#: ../../library/stdtypes.rst:2921
msgid "The only special operation on a module is attribute access: ``m.name``, where *m* is a module and *name* accesses a name defined in *m*'s symbol table. Module attributes can be assigned to.  (Note that the :keyword:`import` statement is not, strictly speaking, an operation on a module object; ``import foo`` does not require a module object named *foo* to exist, rather it requires an (external) *definition* for a module named *foo* somewhere.)"
msgstr ""

#: ../../library/stdtypes.rst:2928
msgid "A special attribute of every module is :attr:`~object.__dict__`. This is the dictionary containing the module's symbol table. Modifying this dictionary will actually change the module's symbol table, but direct assignment to the :attr:`~object.__dict__` attribute is not possible (you can write ``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not recommended."
msgstr ""

#: ../../library/stdtypes.rst:2936
msgid "Modules built into the interpreter are written like this: ``<module 'sys' (built-in)>``.  If loaded from a file, they are written as ``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""

#: ../../library/stdtypes.rst:2944
msgid "Classes and Class Instances"
msgstr ""

#: ../../library/stdtypes.rst:2946
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""

#: ../../library/stdtypes.rst:2952
msgid "Functions"
msgstr ""

#: ../../library/stdtypes.rst:2954
msgid "Function objects are created by function definitions.  The only operation on a function object is to call it: ``func(argument-list)``."
msgstr ""

#: ../../library/stdtypes.rst:2957
msgid "There are really two flavors of function objects: built-in functions and user-defined functions.  Both support the same operation (to call the function), but the implementation is different, hence the different object types."
msgstr ""

#: ../../library/stdtypes.rst:2961
msgid "See :ref:`function` for more information."
msgstr ""

#: ../../library/stdtypes.rst:2967
msgid "Methods"
msgstr ""

#: ../../library/stdtypes.rst:2971
msgid "Methods are functions that are called using the attribute notation. There are two flavors: built-in methods (such as :meth:`append` on lists) and class instance methods.  Built-in methods are described with the types that support them."
msgstr ""

#: ../../library/stdtypes.rst:2976
msgid "The implementation adds two special read-only attributes to class instance methods: ``m.im_self`` is the object on which the method operates, and ``m.im_func`` is the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` is completely equivalent to calling ``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)``."
msgstr ""

#: ../../library/stdtypes.rst:2982
msgid "Class instance methods are either *bound* or *unbound*, referring to whether the method was accessed through an instance or a class, respectively.  When a method is unbound, its ``im_self`` attribute will be ``None`` and if called, an explicit ``self`` object must be passed as the first argument.  In this case, ``self`` must be an instance of the unbound method's class (or a subclass of that class), otherwise a :exc:`TypeError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:2989
msgid "Like function objects, methods objects support getting arbitrary attributes. However, since method attributes are actually stored on the underlying function object (``meth.im_func``), setting method attributes on either bound or unbound methods is disallowed.  Attempting to set an attribute on a method results in an :exc:`AttributeError` being raised.  In order to set a method attribute, you need to explicitly set it on the underlying function object::"
msgstr ""

#: ../../library/stdtypes.rst:3010
#: ../../library/stdtypes.rst:3038
msgid "See :ref:`types` for more information."
msgstr ""

#: ../../library/stdtypes.rst:3018
msgid "Code Objects"
msgstr ""

#: ../../library/stdtypes.rst:3024
msgid "Code objects are used by the implementation to represent \"pseudo-compiled\" executable Python code such as a function body. They differ from function objects because they don't contain a reference to their global execution environment.  Code objects are returned by the built-in :func:`compile` function and can be extracted from function objects through their :attr:`func_code` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../library/stdtypes.rst:3035
msgid "A code object can be executed or evaluated by passing it (instead of a source string) to the :keyword:`exec` statement or the built-in :func:`eval` function."
msgstr ""

#: ../../library/stdtypes.rst:3044
msgid "Type Objects"
msgstr ""

#: ../../library/stdtypes.rst:3050
msgid "Type objects represent the various object types.  An object's type is accessed by the built-in function :func:`type`.  There are no special operations on types.  The standard module :mod:`types` defines names for all standard built-in types."
msgstr ""

#: ../../library/stdtypes.rst:3055
msgid "Types are written like this: ``<type 'int'>``."
msgstr ""

#: ../../library/stdtypes.rst:3061
msgid "The Null Object"
msgstr ""

#: ../../library/stdtypes.rst:3063
msgid "This object is returned by functions that don't explicitly return a value.  It supports no special operations.  There is exactly one null object, named ``None`` (a built-in name)."
msgstr ""

#: ../../library/stdtypes.rst:3067
msgid "It is written as ``None``."
msgstr ""

#: ../../library/stdtypes.rst:3073
msgid "The Ellipsis Object"
msgstr ""

#: ../../library/stdtypes.rst:3075
msgid "This object is used by extended slice notation (see :ref:`slicings`).  It supports no special operations.  There is exactly one ellipsis object, named :const:`Ellipsis` (a built-in name)."
msgstr ""

#: ../../library/stdtypes.rst:3079
msgid "It is written as ``Ellipsis``.  When in a subscript, it can also be written as ``...``, for example ``seq[...]``."
msgstr ""

#: ../../library/stdtypes.rst:3084
msgid "The NotImplemented Object"
msgstr ""

#: ../../library/stdtypes.rst:3086
msgid "This object is returned from comparisons and binary operations when they are asked to operate on types they don't support. See :ref:`comparisons` for more information."
msgstr ""

#: ../../library/stdtypes.rst:3090
msgid "It is written as ``NotImplemented``."
msgstr ""

#: ../../library/stdtypes.rst:3094
msgid "Boolean Values"
msgstr ""

#: ../../library/stdtypes.rst:3096
msgid "Boolean values are the two constant objects ``False`` and ``True``.  They are used to represent truth values (although other values can also be considered false or true).  In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively. The built-in function :func:`bool` can be used to convert any value to a Boolean, if the value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""

#: ../../library/stdtypes.rst:3109
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../library/stdtypes.rst:3115
msgid "Internal Objects"
msgstr ""

#: ../../library/stdtypes.rst:3117
msgid "See :ref:`types` for this information.  It describes stack frame objects, traceback objects, and slice objects."
msgstr ""

#: ../../library/stdtypes.rst:3124
msgid "Special Attributes"
msgstr ""

#: ../../library/stdtypes.rst:3126
msgid "The implementation adds a few special read-only attributes to several object types, where they are relevant.  Some of these are not reported by the :func:`dir` built-in function."
msgstr ""

#: ../../library/stdtypes.rst:3133
msgid "A dictionary or other mapping object used to store an object's (writable) attributes."
msgstr ""

#: ../../library/stdtypes.rst:3139
#: ../../library/stdtypes.rst:3146
msgid "Use the built-in function :func:`dir` to get a list of an object's attributes. This attribute is no longer available."
msgstr ""

#: ../../library/stdtypes.rst:3153
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../library/stdtypes.rst:3158
msgid "The tuple of base classes of a class object."
msgstr ""

#: ../../library/stdtypes.rst:3163
msgid "The name of the class, type, function, method, descriptor, or generator instance."
msgstr ""

#: ../../library/stdtypes.rst:3167
msgid "The following attributes are only supported by :term:`new-style class`\\ es."
msgstr ""

#: ../../library/stdtypes.rst:3171
msgid "This attribute is a tuple of classes that are considered when looking for base classes during method resolution."
msgstr ""

#: ../../library/stdtypes.rst:3177
msgid "This method can be overridden by a metaclass to customize the method resolution order for its instances.  It is called at class instantiation, and its result is stored in :attr:`~class.__mro__`."
msgstr ""

#: ../../library/stdtypes.rst:3184
msgid "Each new-style class keeps a list of weak references to its immediate subclasses.  This method returns a list of all those references still alive. Example::"
msgstr ""

#: ../../library/stdtypes.rst:3193
msgid "Footnotes"
msgstr ""

#: ../../library/stdtypes.rst:3194
msgid "Additional information on these special methods may be found in the Python Reference Manual (:ref:`customization`)."
msgstr ""

#: ../../library/stdtypes.rst:3197
msgid "As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, and similarly for tuples."
msgstr ""

#: ../../library/stdtypes.rst:3200
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""

#: ../../library/stdtypes.rst:3202
msgid "Cased characters are those with general category property being one of \"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:3205
msgid "To format only a tuple you should therefore provide a singleton tuple whose only element is the tuple to be formatted."
msgstr ""

#: ../../library/stdtypes.rst:3208
msgid "The advantage of leaving the newline on is that returning an empty string is then an unambiguous EOF indication.  It is also possible (in cases where it might matter, for example, if you want to make an exact copy of a file while scanning its lines) to tell whether the last line of a file ended in a newline or not (yes this happens!)."
msgstr ""

