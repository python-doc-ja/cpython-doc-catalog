# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-09-18 09:12+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr ""

#: ../../library/asyncio-task.rst:8
msgid "This section outlines high-level asyncio APIs to work with coroutines and Tasks."
msgstr ""

#: ../../library/asyncio-task.rst:19
msgid "Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:21
msgid "Coroutines declared with async/await syntax is the preferred way of writing asyncio applications.  For example, the following snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""

#: ../../library/asyncio-task.rst:36
msgid "Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""

#: ../../library/asyncio-task.rst:42
msgid "To actually run a coroutine asyncio provides three main mechanisms:"
msgstr ""

#: ../../library/asyncio-task.rst:44
msgid "The :func:`asyncio.run` function to run the top-level entry point \"main()\" function (see the above example.)"
msgstr ""

#: ../../library/asyncio-task.rst:47
msgid "Awaiting on a coroutine.  The following snippet of code will print \"hello\" after waiting for 1 second, and then print \"world\" after waiting for *another* 2 seconds::"
msgstr ""

#: ../../library/asyncio-task.rst:68
msgid "Expected output::"
msgstr ""

#: ../../library/asyncio-task.rst:75
msgid "The :func:`asyncio.create_task` function to run coroutines concurrently as asyncio :class:`Tasks <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:78
msgid "Let's modify the above example and run two \"set_after\" coroutines *concurrently*::"
msgstr ""

#: ../../library/asyncio-task.rst:97
msgid "Note that expected output now shows that the snippet runs 1 second faster than before::"
msgstr ""

#: ../../library/asyncio-task.rst:105
msgid "Note that in this documentation the term \"coroutine\" can be used for two closely related concepts:"
msgstr ""

#: ../../library/asyncio-task.rst:108
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr ""

#: ../../library/asyncio-task.rst:110
msgid "a *coroutine object*: object returned by calling a *coroutine function*."
msgstr ""

#: ../../library/asyncio-task.rst:115
msgid "Running an asyncio Program"
msgstr ""

#: ../../library/asyncio-task.rst:119
msgid "This function runs the passed coroutine, taking care of managing the asyncio event loop and finalizing asynchronous generators."
msgstr ""

#: ../../library/asyncio-task.rst:123
msgid "This function cannot be called when another asyncio event loop is running in the same thread."
msgstr ""

#: ../../library/asyncio-task.rst:126
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""

#: ../../library/asyncio-task.rst:128
msgid "This function always creates a new event loop and closes it at the end.  It should be used as a main entry point for asyncio programs, and should ideally only be called once."
msgstr ""

#: ../../library/asyncio-task.rst:132
msgid "**Important:** this function has been added to asyncio in Python 3.7 on a :term:`provisional basis <provisional api>`."
msgstr ""

#: ../../library/asyncio-task.rst:138
msgid "Creating Tasks"
msgstr ""

#: ../../library/asyncio-task.rst:142
msgid "Wrap the *coro* :ref:`coroutine <coroutine>` into a task and schedule its execution. Return the task object."
msgstr ""

#: ../../library/asyncio-task.rst:145
msgid "The task is executed in the loop returned by :func:`get_running_loop`, :exc:`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""

#: ../../library/asyncio-task.rst:153
msgid "Sleeping"
msgstr ""

#: ../../library/asyncio-task.rst:157
msgid "Block for *delay* seconds."
msgstr ""

#: ../../library/asyncio-task.rst:159
msgid "If *result* is provided, it is returned to the caller when the coroutine completes."
msgstr ""

#: ../../library/asyncio-task.rst:164
msgid "Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""

#: ../../library/asyncio-task.rst:183
msgid "Running Tasks Concurrently"
msgstr ""

#: ../../library/asyncio-task.rst:187
msgid "Return a Future aggregating results from the given coroutine objects, Tasks, or Futures."
msgstr ""

#: ../../library/asyncio-task.rst:190
msgid "If all Tasks/Futures are completed successfully, the result is an aggregate list of returned values.  The result values are in the order of the original *fs* sequence."
msgstr ""

#: ../../library/asyncio-task.rst:194
msgid "All coroutines in the *fs* list are automatically scheduled as :class:`Tasks <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:197
msgid "If *return_exceptions* is ``True``, exceptions in the Tasks/Futures are treated the same as successful results, and gathered in the result list.  Otherwise, the first raised exception is immediately propagated to the returned Future."
msgstr ""

#: ../../library/asyncio-task.rst:202
msgid "If the outer Future is *cancelled*, all submitted Tasks/Futures (that have not completed yet) are also *cancelled*."
msgstr ""

#: ../../library/asyncio-task.rst:205
msgid "If any child is *cancelled*, it is treated as if it raised :exc:`CancelledError` -- the outer Future is **not** cancelled in this case.  This is to prevent the cancellation of one submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:210
msgid "All futures must share the same event loop."
msgstr ""

#: ../../library/asyncio-task.rst:212
msgid "If the *gather* itself is cancelled, the cancellation is propagated regardless of *return_exceptions*."
msgstr ""

#: ../../library/asyncio-task.rst:218
#: ../../library/asyncio-task.rst:317
#: ../../library/asyncio-task.rst:400
msgid "Example::"
msgstr ""

#: ../../library/asyncio-task.rst:253
msgid "Shielding Tasks From Cancellation"
msgstr ""

#: ../../library/asyncio-task.rst:257
msgid "Wait for a Future/Task while protecting it from being cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:259
#: ../../library/asyncio-task.rst:297
msgid "*fut* can be a coroutine, a Task, or a Future-like object.  If *fut* is a coroutine it is automatically scheduled as a :class:`Task`."
msgstr ""

#: ../../library/asyncio-task.rst:263
msgid "The statement::"
msgstr ""

#: ../../library/asyncio-task.rst:267
msgid "is equivalent to::"
msgstr ""

#: ../../library/asyncio-task.rst:271
msgid "*except* that if the coroutine containing it is cancelled, the Task running in ``something()`` is not cancelled.  From the point of view of ``something()``, the cancellation did not happen. Although its caller is still cancelled, so the \"await\" expression still raises a :exc:`CancelledError`."
msgstr ""

#: ../../library/asyncio-task.rst:277
msgid "If ``something()`` is cancelled by other means (i.e. from within itself) that would also cancel ``shield()``."
msgstr ""

#: ../../library/asyncio-task.rst:280
msgid "If it is desired to completely ignore cancellation (not recommended) the ``shield()`` function should be combined with a try/except clause, as follows::"
msgstr ""

#: ../../library/asyncio-task.rst:291
msgid "Timeouts"
msgstr ""

#: ../../library/asyncio-task.rst:295
msgid "Wait for a coroutine, Task, or Future to complete with timeout."
msgstr ""

#: ../../library/asyncio-task.rst:301
msgid "*timeout* can either be ``None`` or a float or int number of seconds to wait for.  If *timeout* is ``None``, block until the future completes."
msgstr ""

#: ../../library/asyncio-task.rst:305
msgid "If a timeout occurs, it cancels the task and raises :exc:`asyncio.TimeoutError`."
msgstr ""

#: ../../library/asyncio-task.rst:308
msgid "To avoid the task cancellation, wrap it in :func:`shield`."
msgstr ""

#: ../../library/asyncio-task.rst:310
msgid "The function will wait until the future is actually cancelled, so the total wait time may exceed the *timeout*."
msgstr ""

#: ../../library/asyncio-task.rst:313
msgid "If the wait is cancelled, the future *fut* is also cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:337
msgid "When *fut* is cancelled due to a timeout, ``wait_for`` waits for *fut* to be cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""

#: ../../library/asyncio-task.rst:344
msgid "Waiting Primitives"
msgstr ""

#: ../../library/asyncio-task.rst:349
msgid "Wait for a set of coroutines, Tasks, or Futures to complete."
msgstr ""

#: ../../library/asyncio-task.rst:351
msgid "*fs* is a list of coroutines, Futures, and/or Tasks.  Coroutines are automatically scheduled as :class:`Tasks <Task>`."
msgstr ""

#: ../../library/asyncio-task.rst:354
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr ""

#: ../../library/asyncio-task.rst:356
msgid "*timeout* (a float or int), if specified, can be used to control the maximum number of seconds to wait before returning."
msgstr ""

#: ../../library/asyncio-task.rst:359
msgid "Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures or Tasks that aren't done when the timeout occurs are simply returned in the second set."
msgstr ""

#: ../../library/asyncio-task.rst:363
msgid "*return_when* indicates when this function should return.  It must be one of the following constants:"
msgstr ""

#: ../../library/asyncio-task.rst:369
msgid "Constant"
msgstr ""

#: ../../library/asyncio-task.rst:369
msgid "Description"
msgstr ""

#: ../../library/asyncio-task.rst:371
msgid ":const:`FIRST_COMPLETED`"
msgstr ""

#: ../../library/asyncio-task.rst:371
msgid "The function will return when any future finishes or is cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:374
msgid ":const:`FIRST_EXCEPTION`"
msgstr ""

#: ../../library/asyncio-task.rst:374
msgid "The function will return when any future finishes by raising an exception.  If no future raises an exception then it is equivalent to :const:`ALL_COMPLETED`."
msgstr ""

#: ../../library/asyncio-task.rst:380
msgid ":const:`ALL_COMPLETED`"
msgstr ""

#: ../../library/asyncio-task.rst:380
msgid "The function will return when all futures finish or are cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:384
msgid "Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures when a timeout occurs."
msgstr ""

#: ../../library/asyncio-task.rst:387
msgid "Usage::"
msgstr ""

#: ../../library/asyncio-task.rst:394
msgid "Return an iterator of awaitables which return :class:`Future` instances."
msgstr ""

#: ../../library/asyncio-task.rst:397
msgid "Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures are done."
msgstr ""

#: ../../library/asyncio-task.rst:408
msgid "Scheduling From Other Threads"
msgstr ""

#: ../../library/asyncio-task.rst:412
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""

#: ../../library/asyncio-task.rst:414
msgid "Return a :class:`concurrent.futures.Future` to access the result."
msgstr ""

#: ../../library/asyncio-task.rst:416
msgid "This function is meant to be called from a different OS thread than the one where the event loop is running.  Example::"
msgstr ""

#: ../../library/asyncio-task.rst:428
msgid "If an exception is raised in the coroutine, the returned Future will be notified.  It can also be used to cancel the task in the event loop::"
msgstr ""

#: ../../library/asyncio-task.rst:442
msgid "See the :ref:`concurrency and multithreading <asyncio-multithreading>` section of the documentation."
msgstr ""

#: ../../library/asyncio-task.rst:445
msgid "Unlike other asyncio functions this functions requires the *loop* argument to be passed explicitly."
msgstr ""

#: ../../library/asyncio-task.rst:452
msgid "Introspection"
msgstr ""

#: ../../library/asyncio-task.rst:457
msgid "Return the currently running :class:`Task` instance, or ``None`` if no task is running."
msgstr ""

#: ../../library/asyncio-task.rst:460
msgid "If *loop* is ``None`` :func:`get_running_loop` is used to get the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:468
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""

#: ../../library/asyncio-task.rst:471
msgid "If *loop* is ``None``, :func:`get_running_loop` is used for getting current loop."
msgstr ""

#: ../../library/asyncio-task.rst:478
msgid "Task Object"
msgstr ""

#: ../../library/asyncio-task.rst:482
msgid "A :class:`Future`-like object that wraps a Python :ref:`coroutine <coroutine>`.  Not thread-safe."
msgstr ""

#: ../../library/asyncio-task.rst:485
msgid "Tasks are used to run coroutines in event loops. If a coroutine awaits on a Future, the Task suspends the execution of the coroutine and waits for the completion of the Future.  When the Future is *done*, the execution of the wrapped coroutine resumes."
msgstr ""

#: ../../library/asyncio-task.rst:491
msgid "Event loops use cooperative scheduling: an event loop runs one Task at a time.  While a Task awaits for the completion of a Future, the event loop runs other Tasks, callbacks, or performs IO operations."
msgstr ""

#: ../../library/asyncio-task.rst:496
msgid "Use the high-level :func:`asyncio.create_task` function to create Tasks, or the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  Manual instantiation of Tasks is discouraged."
msgstr ""

#: ../../library/asyncio-task.rst:501
msgid "To cancel a running Task use the :meth:`cancel` method.  Calling it will cause the Task to throw a :exc:`CancelledError` exception into the wrapped coroutine.  If a coroutine is awaiting on a Future object during cancellation, the Future object will be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:506
msgid ":meth:`cancelled` can be used to check if the Task was cancelled. The method returns ``True`` if the wrapped coroutine did not suppress the :exc:`CancelledError` exception and was actually cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:511
msgid ":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""

#: ../../library/asyncio-task.rst:515
msgid "Tasks support the :mod:`contextvars` module.  When a Task is created it copies the current context and later runs its coroutine in the copied context."
msgstr ""

#: ../../library/asyncio-task.rst:519
msgid "Added support for the :mod:`contextvars` module."
msgstr ""

#: ../../library/asyncio-task.rst:524
msgid "Request the Task to be cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:526
msgid "This arranges for a :exc:`CancelledError` exception to be thrown into the wrapped coroutine on the next cycle of the event loop."
msgstr ""

#: ../../library/asyncio-task.rst:529
msgid "The coroutine then has a chance to clean up or even deny the request by suppressing the exception with a :keyword:`try` ... ... ``except CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will be cancelled, although suppressing cancellation completely is not common and is actively discouraged."
msgstr ""

#: ../../library/asyncio-task.rst:539
msgid "The following example illustrates how coroutines can intercept the cancellation request::"
msgstr ""

#: ../../library/asyncio-task.rst:578
msgid "Return ``True`` if the Task is *cancelled*."
msgstr ""

#: ../../library/asyncio-task.rst:580
msgid "The Task is *cancelled* when the cancellation was requested with :meth:`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` exception thrown into it."
msgstr ""

#: ../../library/asyncio-task.rst:586
msgid "Return ``True`` if the Task is *done*."
msgstr ""

#: ../../library/asyncio-task.rst:588
msgid "A Task is *done* when the wrapped coroutine either returned a value, raised an exception, or the Task was cancelled."
msgstr ""

#: ../../library/asyncio-task.rst:593
msgid "Return the list of stack frames for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:595
msgid "If the wrapped coroutine is not done, this returns the stack where it is suspended.  If the coroutine has completed successfully or was cancelled, this returns an empty list. If the coroutine was terminated by an exception, this returns the list of traceback frames."
msgstr ""

#: ../../library/asyncio-task.rst:601
msgid "The frames are always ordered from oldest to newest."
msgstr ""

#: ../../library/asyncio-task.rst:603
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr ""

#: ../../library/asyncio-task.rst:605
msgid "The optional *limit* argument sets the maximum number of frames to return; by default all available frames are returned. The ordering of the returned list differs depending on whether a stack or a traceback is returned: the newest frames of a stack are returned, but the oldest frames of a traceback are returned.  (This matches the behavior of the traceback module.)"
msgstr ""

#: ../../library/asyncio-task.rst:614
msgid "Print the stack or traceback for this Task."
msgstr ""

#: ../../library/asyncio-task.rst:616
msgid "This produces output similar to that of the traceback module for the frames retrieved by :meth:`get_stack`."
msgstr ""

#: ../../library/asyncio-task.rst:619
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr ""

#: ../../library/asyncio-task.rst:621
msgid "The *file* argument is an I/O stream to which the output is written; by default output is written to :data:`sys.stderr`."
msgstr ""

#: ../../library/asyncio-task.rst:626
msgid "Return a set of all tasks for an event loop."
msgstr ""

#: ../../library/asyncio-task.rst:628
msgid "By default all tasks for the current event loop are returned. If *loop* is ``None``, the :func:`get_event_loop` function is used to get the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:632
msgid "This method is **deprecated** and will be removed in Python 3.9.  Use the :func:`all_tasks` function instead."
msgstr ""

#: ../../library/asyncio-task.rst:637
msgid "Return the currently running task or ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:639
msgid "If *loop* is ``None``, the :func:`get_event_loop` function is used to get the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:642
msgid "This method is **deprecated** and will be removed in Python 3.9.  Use the :func:`current_task` function instead."
msgstr ""

#: ../../library/asyncio-task.rst:649
msgid "Generator-based Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:653
msgid "Support for generator-based coroutines is **deprecated** and is scheduled for removal in Python 4.0."
msgstr ""

#: ../../library/asyncio-task.rst:656
msgid "Generator-based coroutines predate async/await syntax.  They are Python generators that use ``yield from`` expressions to await on Futures and other coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:660
msgid "Generator-based coroutines should be decorated with :func:`@asyncio.coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""

#: ../../library/asyncio-task.rst:667
msgid "Decorator to mark generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:669
msgid "This decorator enables legacy generator-based coroutines to be compatible with async/await code::"
msgstr ""

#: ../../library/asyncio-task.rst:679
msgid "This decorator is **deprecated** and is scheduled for removal in Python 4.0."
msgstr ""

#: ../../library/asyncio-task.rst:682
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:687
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:689
msgid "This method is different from :func:`inspect.iscoroutine` because it returns ``True`` for generator-based coroutines decorated with :func:`@coroutine <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:695
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:698
msgid "This method is different from :func:`inspect.iscoroutinefunction` because it returns ``True`` for generator-based coroutine functions decorated with :func:`@coroutine <coroutine>`."
msgstr ""

