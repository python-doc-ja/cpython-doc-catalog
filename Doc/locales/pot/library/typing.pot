# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-20 04:23+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/typing.rst:3
msgid ":mod:`typing` --- Support for type hints"
msgstr ""

#: ../../library/typing.rst:10
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr ""

#: ../../library/typing.rst:14
msgid "The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc."
msgstr ""

#: ../../library/typing.rst:20
msgid "This module provides runtime support for type hints as specified by :pep:`484`, :pep:`526`, :pep:`544`, :pep:`586`, :pep:`589`, and :pep:`591`. The most fundamental support consists of the types :data:`Any`, :data:`Union`, :data:`Tuple`, :data:`Callable`, :class:`TypeVar`, and :class:`Generic`.  For full specification please see :pep:`484`.  For a simplified introduction to type hints see :pep:`483`."
msgstr ""

#: ../../library/typing.rst:28
msgid "The function below takes and returns a string and is annotated as follows::"
msgstr ""

#: ../../library/typing.rst:33
msgid "In the function ``greeting``, the argument ``name`` is expected to be of type :class:`str` and the return type :class:`str`. Subtypes are accepted as arguments."
msgstr ""

#: ../../library/typing.rst:38
msgid "Type aliases"
msgstr ""

#: ../../library/typing.rst:40
msgid "A type alias is defined by assigning the type to the alias. In this example, ``Vector`` and ``list[float]`` will be treated as interchangeable synonyms::"
msgstr ""

#: ../../library/typing.rst:51
msgid "Type aliases are useful for simplifying complex type signatures. For example::"
msgstr ""

#: ../../library/typing.rst:69
msgid "Note that ``None`` as a type hint is a special case and is replaced by ``type(None)``."
msgstr ""

#: ../../library/typing.rst:75
msgid "NewType"
msgstr ""

#: ../../library/typing.rst:77
msgid "Use the :func:`NewType` helper function to create distinct types::"
msgstr ""

#: ../../library/typing.rst:84
msgid "The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors::"
msgstr ""

#: ../../library/typing.rst:96
msgid "You may still perform all ``int`` operations on a variable of type ``UserId``, but the result will always be of type ``int``. This lets you pass in a ``UserId`` wherever an ``int`` might be expected, but will prevent you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""

#: ../../library/typing.rst:104
msgid "Note that these checks are enforced only by the static type checker. At runtime, the statement ``Derived = NewType('Derived', Base)`` will make ``Derived`` a function that immediately returns whatever parameter you pass it. That means the expression ``Derived(some_value)`` does not create a new class or introduce any overhead beyond that of a regular function call."
msgstr ""

#: ../../library/typing.rst:110
msgid "More precisely, the expression ``some_value is Derived(some_value)`` is always true at runtime."
msgstr ""

#: ../../library/typing.rst:113
msgid "This also means that it is not possible to create a subtype of ``Derived`` since it is an identity function at runtime, not an actual type::"
msgstr ""

#: ../../library/typing.rst:123
msgid "However, it is possible to create a :func:`NewType` based on a 'derived' ``NewType``::"
msgstr ""

#: ../../library/typing.rst:131
msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr ""

#: ../../library/typing.rst:133
msgid "See :pep:`484` for more details."
msgstr ""

#: ../../library/typing.rst:137
msgid "Recall that the use of a type alias declares two types to be *equivalent* to one another. Doing ``Alias = Original`` will make the static type checker treat ``Alias`` as being *exactly equivalent* to ``Original`` in all cases. This is useful when you want to simplify complex type signatures."
msgstr ""

#: ../../library/typing.rst:142
msgid "In contrast, ``NewType`` declares one type to be a *subtype* of another. Doing ``Derived = NewType('Derived', Original)`` will make the static type checker treat ``Derived`` as a *subclass* of ``Original``, which means a value of type ``Original`` cannot be used in places where a value of type ``Derived`` is expected. This is useful when you want to prevent logic errors with minimal runtime cost."
msgstr ""

#: ../../library/typing.rst:152
msgid "Callable"
msgstr ""

#: ../../library/typing.rst:154
msgid "Frameworks expecting callback functions of specific signatures might be type hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""

#: ../../library/typing.rst:157
msgid "For example::"
msgstr ""

#: ../../library/typing.rst:168
msgid "It is possible to declare the return type of a callable without specifying the call signature by substituting a literal ellipsis for the list of arguments in the type hint: ``Callable[..., ReturnType]``."
msgstr ""

#: ../../library/typing.rst:175
msgid "Generics"
msgstr ""

#: ../../library/typing.rst:177
msgid "Since type information about objects kept in containers cannot be statically inferred in a generic way, abstract base classes have been extended to support subscription to denote expected types for container elements."
msgstr ""

#: ../../library/typing.rst:188
msgid "Generics can be parameterized by using a new factory available in typing called :class:`TypeVar`."
msgstr ""

#: ../../library/typing.rst:203
msgid "User-defined generic types"
msgstr ""

#: ../../library/typing.rst:205
msgid "A user-defined class can be defined as a generic class."
msgstr ""

#: ../../library/typing.rst:231
msgid "``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes a single type parameter ``T`` . This also makes ``T`` valid as a type within the class body."
msgstr ""

#: ../../library/typing.rst:235
msgid "The :class:`Generic` base class defines :meth:`__class_getitem__` so that ``LoggedVar[t]`` is valid as a type::"
msgstr ""

#: ../../library/typing.rst:244
msgid "A generic type can have any number of type variables, and type variables may be constrained::"
msgstr ""

#: ../../library/typing.rst:256
msgid "Each type variable argument to :class:`Generic` must be distinct. This is thus invalid::"
msgstr ""

#: ../../library/typing.rst:267
msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr ""

#: ../../library/typing.rst:277
msgid "When inheriting from generic classes, some type variables could be fixed::"
msgstr ""

#: ../../library/typing.rst:287
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr ""

#: ../../library/typing.rst:289
msgid "Using a generic class without specifying type parameters assumes :data:`Any` for each position. In the following example, ``MyIterable`` is not generic but implicitly inherits from ``Iterable[Any]``::"
msgstr ""

#: ../../library/typing.rst:297
msgid "User defined generic type aliases are also supported. Examples::"
msgstr ""

#: ../../library/typing.rst:314
msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ""

#: ../../library/typing.rst:317
msgid "A user-defined generic class can have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality."
msgstr ""

#: ../../library/typing.rst:324
msgid "The :data:`Any` type"
msgstr ""

#: ../../library/typing.rst:326
msgid "A special kind of type is :data:`Any`. A static type checker will treat every type as being compatible with :data:`Any` and :data:`Any` as being compatible with every type."
msgstr ""

#: ../../library/typing.rst:330
msgid "This means that it is possible to perform any operation or method call on a value of type :data:`Any` and assign it to any variable::"
msgstr ""

#: ../../library/typing.rst:348
msgid "Notice that no typechecking is performed when assigning a value of type :data:`Any` to a more precise type. For example, the static type checker did not report an error when assigning ``a`` to ``s`` even though ``s`` was declared to be of type :class:`str` and receives an :class:`int` value at runtime!"
msgstr ""

#: ../../library/typing.rst:354
msgid "Furthermore, all functions without a return type or parameter types will implicitly default to using :data:`Any`::"
msgstr ""

#: ../../library/typing.rst:367
msgid "This behavior allows :data:`Any` to be used as an *escape hatch* when you need to mix dynamically and statically typed code."
msgstr ""

#: ../../library/typing.rst:370
msgid "Contrast the behavior of :data:`Any` with the behavior of :class:`object`. Similar to :data:`Any`, every type is a subtype of :class:`object`. However, unlike :data:`Any`, the reverse is not true: :class:`object` is *not* a subtype of every other type."
msgstr ""

#: ../../library/typing.rst:375
msgid "That means when the type of a value is :class:`object`, a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example::"
msgstr ""

#: ../../library/typing.rst:397
msgid "Use :class:`object` to indicate that a value could be any type in a typesafe manner. Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""

#: ../../library/typing.rst:402
msgid "Nominal vs structural subtyping"
msgstr ""

#: ../../library/typing.rst:404
msgid "Initially :pep:`484` defined Python static type system as using *nominal subtyping*. This means that a class ``A`` is allowed where a class ``B`` is expected if and only if ``A`` is a subclass of ``B``."
msgstr ""

#: ../../library/typing.rst:408
msgid "This requirement previously also applied to abstract base classes, such as :class:`~collections.abc.Iterable`. The problem with this approach is that a class had to be explicitly marked to support them, which is unpythonic and unlike what one would normally do in idiomatic dynamically typed Python code. For example, this conforms to :pep:`484`::"
msgstr ""

#: ../../library/typing.rst:421
msgid ":pep:`544` allows to solve this problem by allowing users to write the above code without explicit base classes in the class definition, allowing ``Bucket`` to be implicitly considered a subtype of both ``Sized`` and ``Iterable[int]`` by static type checkers. This is known as *structural subtyping* (or static duck-typing)::"
msgstr ""

#: ../../library/typing.rst:437
msgid "Moreover, by subclassing a special class :class:`Protocol`, a user can define new custom protocols to fully enjoy structural subtyping (see examples below)."
msgstr ""

#: ../../library/typing.rst:442
msgid "Module contents"
msgstr ""

#: ../../library/typing.rst:444
msgid "The module defines the following classes, functions and decorators."
msgstr ""

#: ../../library/typing.rst:448
msgid "This module defines several types that are subclasses of pre-existing standard library classes which also extend :class:`Generic` to support type variables inside ``[]``. These types became redundant in Python 3.9 when the corresponding pre-existing classes were enhanced to support ``[]``."
msgstr ""

#: ../../library/typing.rst:454
msgid "The redundant types are deprecated as of Python 3.9 but no deprecation warnings will be issued by the interpreter. It is expected that type checkers will flag the deprecated types when the checked program targets Python 3.9 or newer."
msgstr ""

#: ../../library/typing.rst:459
msgid "The deprecated types will be removed from the :mod:`typing` module in the first Python version released 5 years after the release of Python 3.9.0. See details in :pep:`585`—*Type Hinting Generics In Standard Collections*."
msgstr ""

#: ../../library/typing.rst:465
msgid "Special typing primitives"
msgstr ""

#: ../../library/typing.rst:468
msgid "Special types"
msgstr ""

#: ../../library/typing.rst:470
msgid "These can be used as types in annotations and do not support ``[]``."
msgstr ""

#: ../../library/typing.rst:474
msgid "Special type indicating an unconstrained type."
msgstr ""

#: ../../library/typing.rst:476
msgid "Every type is compatible with :data:`Any`."
msgstr ""

#: ../../library/typing.rst:477
msgid ":data:`Any` is compatible with every type."
msgstr ""

#: ../../library/typing.rst:481
msgid "Special type indicating that a function never returns. For example::"
msgstr ""

#: ../../library/typing.rst:493
msgid "Special forms"
msgstr ""

#: ../../library/typing.rst:495
msgid "These can be used as types in annotations using ``[]``, each having a unique syntax."
msgstr ""

#: ../../library/typing.rst:499
msgid "Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items with the first item of type X and the second of type Y. The type of the empty tuple can be written as ``Tuple[()]``."
msgstr ""

#: ../../library/typing.rst:503
msgid "Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to type variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an int, a float and a string."
msgstr ""

#: ../../library/typing.rst:507
msgid "To specify a variable-length tuple of homogeneous type, use literal ellipsis, e.g. ``Tuple[int, ...]``. A plain :data:`Tuple` is equivalent to ``Tuple[Any, ...]``, and in turn to :class:`tuple`."
msgstr ""

#: ../../library/typing.rst:511
msgid ":class:`builtins.tuple <tuple>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:516
msgid "Union type; ``Union[X, Y]`` means either X or Y."
msgstr ""

#: ../../library/typing.rst:518
msgid "To define a union, use e.g. ``Union[int, str]``.  Details:"
msgstr ""

#: ../../library/typing.rst:520
msgid "The arguments must be types and there must be at least one."
msgstr ""

#: ../../library/typing.rst:522
msgid "Unions of unions are flattened, e.g.::"
msgstr ""

#: ../../library/typing.rst:526
msgid "Unions of a single argument vanish, e.g.::"
msgstr ""

#: ../../library/typing.rst:530
msgid "Redundant arguments are skipped, e.g.::"
msgstr ""

#: ../../library/typing.rst:534
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr ""

#: ../../library/typing.rst:538
msgid "You cannot subclass or instantiate a union."
msgstr ""

#: ../../library/typing.rst:540
msgid "You cannot write ``Union[X][Y]``."
msgstr ""

#: ../../library/typing.rst:542
msgid "You can use ``Optional[X]`` as a shorthand for ``Union[X, None]``."
msgstr ""

#: ../../library/typing.rst:544
msgid "Don't remove explicit subclasses from unions at runtime."
msgstr ""

#: ../../library/typing.rst:549
msgid "Optional type."
msgstr ""

#: ../../library/typing.rst:551
msgid "``Optional[X]`` is equivalent to ``Union[X, None]``."
msgstr ""

#: ../../library/typing.rst:553
msgid "Note that this is not the same concept as an optional argument, which is one that has a default.  An optional argument with a default does not require the ``Optional`` qualifier on its type annotation just because it is optional. For example::"
msgstr ""

#: ../../library/typing.rst:561
msgid "On the other hand, if an explicit value of ``None`` is allowed, the use of ``Optional`` is appropriate, whether the argument is optional or not. For example::"
msgstr ""

#: ../../library/typing.rst:570
msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr ""

#: ../../library/typing.rst:572
msgid "The subscription syntax must always be used with exactly two values: the argument list and the return type.  The argument list must be a list of types or an ellipsis; the return type must be a single type."
msgstr ""

#: ../../library/typing.rst:577
msgid "There is no syntax to indicate optional or keyword arguments; such function types are rarely used as callback types. ``Callable[..., ReturnType]`` (literal ellipsis) can be used to type hint a callable taking any number of arguments and returning ``ReturnType``.  A plain :data:`Callable` is equivalent to ``Callable[..., Any]``, and in turn to :class:`collections.abc.Callable`."
msgstr ""

#: ../../library/typing.rst:585
msgid ":class:`collections.abc.Callable` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:590
msgid "A variable annotated with ``C`` may accept a value of type ``C``. In contrast, a variable annotated with ``Type[C]`` may accept values that are classes themselves -- specifically, it will accept the *class object* of ``C``. For example::"
msgstr ""

#: ../../library/typing.rst:599
msgid "Note that ``Type[C]`` is covariant::"
msgstr ""

#: ../../library/typing.rst:611
msgid "The fact that ``Type[C]`` is covariant implies that all subclasses of ``C`` should implement the same constructor signature and class method signatures as ``C``. The type checker should flag violations of this, but should also allow constructor calls in subclasses that match the constructor calls in the indicated base class. How the type checker is required to handle this particular case may change in future revisions of :pep:`484`."
msgstr ""

#: ../../library/typing.rst:619
msgid "The only legal parameters for :class:`Type` are classes, :data:`Any`, :ref:`type variables <generics>`, and unions of any of these types. For example::"
msgstr ""

#: ../../library/typing.rst:625
msgid "``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent to ``type``, which is the root of Python's metaclass hierarchy."
msgstr ""

#: ../../library/typing.rst:630
msgid ":class:`builtins.type <type>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:635
msgid "A type that can be used to indicate to type checkers that the corresponding variable or function parameter has a value equivalent to the provided literal (or one of several literals). For example::"
msgstr ""

#: ../../library/typing.rst:649
msgid "``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is allowed as type argument to ``Literal[...]``, but type checkers may impose restrictions. See :pep:`586` for more details about literal types."
msgstr ""

#: ../../library/typing.rst:657
msgid "Special type construct to mark class variables."
msgstr ""

#: ../../library/typing.rst:659
msgid "As introduced in :pep:`526`, a variable annotation wrapped in ClassVar indicates that a given attribute is intended to be used as a class variable and should not be set on instances of that class. Usage::"
msgstr ""

#: ../../library/typing.rst:667
msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ""

#: ../../library/typing.rst:669
msgid ":data:`ClassVar` is not a class itself, and should not be used with :func:`isinstance` or :func:`issubclass`. :data:`ClassVar` does not change Python runtime behavior, but it can be used by third-party type checkers. For example, a type checker might flag the following code as an error::"
msgstr ""

#: ../../library/typing.rst:683
msgid "A special typing construct to indicate to type checkers that a name cannot be re-assigned or overridden in a subclass. For example::"
msgstr ""

#: ../../library/typing.rst:695
#: ../../library/typing.rst:1573
msgid "There is no runtime checking of these properties. See :pep:`591` for more details."
msgstr ""

#: ../../library/typing.rst:702
msgid "A type, introduced in :pep:`593` (``Flexible function and variable annotations``), to decorate existing types with context-specific metadata (possibly multiple pieces of it, as ``Annotated`` is variadic). Specifically, a type ``T`` can be annotated with metadata ``x`` via the typehint ``Annotated[T, x]``. This metadata can be used for either static analysis or at runtime. If a library (or tool) encounters a typehint ``Annotated[T, x]`` and has no special logic for metadata ``x``, it should ignore it and simply treat the type as ``T``. Unlike the ``no_type_check`` functionality that currently exists in the ``typing`` module which completely disables typechecking annotations on a function or a class, the ``Annotated`` type allows for both static typechecking of ``T`` (e.g., via mypy or Pyre, which can safely ignore ``x``) together with runtime access to ``x`` within a specific application."
msgstr ""

#: ../../library/typing.rst:716
msgid "Ultimately, the responsibility of how to interpret the annotations (if at all) is the responsibility of the tool or library encountering the ``Annotated`` type. A tool or library encountering an ``Annotated`` type can scan through the annotations to determine if they are of interest (e.g., using ``isinstance()``)."
msgstr ""

#: ../../library/typing.rst:722
msgid "When a tool or a library does not support annotations or encounters an unknown annotation it should just ignore it and treat annotated type as the underlying type."
msgstr ""

#: ../../library/typing.rst:726
msgid "It's up to the tool consuming the annotations to decide whether the client is allowed to have several annotations on one type and how to merge those annotations."
msgstr ""

#: ../../library/typing.rst:730
msgid "Since the ``Annotated`` type allows you to put several annotations of the same (or different) type(s) on any node, the tools or libraries consuming those annotations are in charge of dealing with potential duplicates. For example, if you are doing value range analysis you might allow this::"
msgstr ""

#: ../../library/typing.rst:739
msgid "Passing ``include_extras=True`` to :func:`get_type_hints` lets one access the extra annotations at runtime."
msgstr ""

#: ../../library/typing.rst:742
msgid "The details of the syntax:"
msgstr ""

#: ../../library/typing.rst:744
msgid "The first argument to ``Annotated`` must be a valid type"
msgstr ""

#: ../../library/typing.rst:746
msgid "Multiple type annotations are supported (``Annotated`` supports variadic arguments)::"
msgstr ""

#: ../../library/typing.rst:751
msgid "``Annotated`` must be called with at least two arguments ( ``Annotated[int]`` is not valid)"
msgstr ""

#: ../../library/typing.rst:754
msgid "The order of the annotations is preserved and matters for equality checks::"
msgstr ""

#: ../../library/typing.rst:761
msgid "Nested ``Annotated`` types are flattened, with metadata ordered starting with the innermost annotation::"
msgstr ""

#: ../../library/typing.rst:768
msgid "Duplicated annotations are not removed::"
msgstr ""

#: ../../library/typing.rst:774
msgid "``Annotated`` can be used with nested and generic aliases::"
msgstr ""

#: ../../library/typing.rst:785
msgid "Building generic types"
msgstr ""

#: ../../library/typing.rst:787
msgid "These are not used in annotations. They are building blocks for creating generic types."
msgstr ""

#: ../../library/typing.rst:791
msgid "Abstract base class for generic types."
msgstr ""

#: ../../library/typing.rst:793
msgid "A generic type is typically declared by inheriting from an instantiation of this class with one or more type variables. For example, a generic mapping type might be defined as::"
msgstr ""

#: ../../library/typing.rst:802
msgid "This class can then be used as follows::"
msgstr ""

#: ../../library/typing.rst:815
msgid "Type variable."
msgstr ""

#: ../../library/typing.rst:817
#: ../../library/typing.rst:933
msgid "Usage::"
msgstr ""

#: ../../library/typing.rst:822
msgid "Type variables exist primarily for the benefit of static type checkers.  They serve as the parameters for generic types as well as for generic function definitions.  See :class:`Generic` for more information on generic types.  Generic functions work as follows::"
msgstr ""

#: ../../library/typing.rst:835
msgid "The latter example's signature is essentially the overloading of ``(str, str) -> str`` and ``(bytes, bytes) -> bytes``.  Also note that if the arguments are instances of some subclass of :class:`str`, the return type is still plain :class:`str`."
msgstr ""

#: ../../library/typing.rst:840
msgid "At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In general, :func:`isinstance` and :func:`issubclass` should not be used with types."
msgstr ""

#: ../../library/typing.rst:843
msgid "Type variables may be marked covariant or contravariant by passing ``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more details.  By default type variables are invariant.  Alternatively, a type variable may specify an upper bound using ``bound=<type>``. This means that an actual type substituted (explicitly or implicitly) for the type variable must be a subclass of the boundary type, see :pep:`484`."
msgstr ""

#: ../../library/typing.rst:853
msgid "``AnyStr`` is a type variable defined as ``AnyStr = TypeVar('AnyStr', str, bytes)``."
msgstr ""

#: ../../library/typing.rst:856
msgid "It is meant to be used for functions that may accept any kind of string without allowing different kinds of strings to mix. For example::"
msgstr ""

#: ../../library/typing.rst:868
msgid "Base class for protocol classes. Protocol classes are defined like this::"
msgstr ""

#: ../../library/typing.rst:874
msgid "Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::"
msgstr ""

#: ../../library/typing.rst:886
msgid "See :pep:`544` for details. Protocol classes decorated with :func:`runtime_checkable` (described later) act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures."
msgstr ""

#: ../../library/typing.rst:891
msgid "Protocol classes can be generic, for example::"
msgstr ""

#: ../../library/typing.rst:901
msgid "Mark a protocol class as a runtime protocol."
msgstr ""

#: ../../library/typing.rst:903
msgid "Such a protocol can be used with :func:`isinstance` and :func:`issubclass`. This raises :exc:`TypeError` when applied to a non-protocol class.  This allows a simple-minded structural check, very similar to \"one trick ponies\" in :mod:`collections.abc` such as :class:`~collections.abc.Iterable`.  For example::"
msgstr ""

#: ../../library/typing.rst:916
msgid ":func:`runtime_checkable` will check only the presence of the required methods, not their type signatures! For example, :class:`builtins.complex <complex>` implements :func:`__float__`, therefore it passes an :func:`issubclass` check against :class:`SupportsFloat`. However, the ``complex.__float__`` method exists only to raise a :class:`TypeError` with a more informative message."
msgstr ""

#: ../../library/typing.rst:925
msgid "Other special directives"
msgstr ""

#: ../../library/typing.rst:927
msgid "These are not used in annotations. They are building blocks for declaring types."
msgstr ""

#: ../../library/typing.rst:931
msgid "Typed version of :func:`collections.namedtuple`."
msgstr ""

#: ../../library/typing.rst:939
msgid "This is equivalent to::"
msgstr ""

#: ../../library/typing.rst:943
msgid "To give a field a default value, you can assign to it in the class body::"
msgstr ""

#: ../../library/typing.rst:952
msgid "Fields with a default value must come after any fields without a default."
msgstr ""

#: ../../library/typing.rst:954
msgid "The resulting class has an extra attribute ``__annotations__`` giving a dict that maps the field names to the field types.  (The field names are in the ``_fields`` attribute and the default values are in the ``_field_defaults`` attribute both of which are part of the namedtuple API.)"
msgstr ""

#: ../../library/typing.rst:960
msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr ""

#: ../../library/typing.rst:970
msgid "Backward-compatible usage::"
msgstr ""

#: ../../library/typing.rst:974
msgid "Added support for :pep:`526` variable annotation syntax."
msgstr ""

#: ../../library/typing.rst:977
msgid "Added support for default values, methods, and docstrings."
msgstr ""

#: ../../library/typing.rst:980
msgid "The ``_field_types`` and ``__annotations__`` attributes are now regular dictionaries instead of instances of ``OrderedDict``."
msgstr ""

#: ../../library/typing.rst:984
msgid "Removed the ``_field_types`` attribute in favor of the more standard ``__annotations__`` attribute which has the same information."
msgstr ""

#: ../../library/typing.rst:990
msgid "A helper function to indicate a distinct type to a typechecker, see :ref:`distinct`. At runtime it returns a function that returns its argument. Usage::"
msgstr ""

#: ../../library/typing.rst:1001
msgid "Special construct to add type hints to a dictionary. At runtime it is a plain :class:`dict`."
msgstr ""

#: ../../library/typing.rst:1004
msgid "``TypedDict`` declares a dictionary type that expects all of its instances to have a certain set of keys, where each key is associated with a value of a consistent type. This expectation is not checked at runtime but is only enforced by type checkers. Usage::"
msgstr ""

#: ../../library/typing.rst:1020
msgid "The type info for introspection can be accessed via ``Point2D.__annotations__`` and ``Point2D.__total__``.  To allow using this feature with older versions of Python that do not support :pep:`526`, ``TypedDict`` supports two additional equivalent syntactic forms::"
msgstr ""

#: ../../library/typing.rst:1028
msgid "By default, all keys must be present in a TypedDict. It is possible to override this by specifying totality. Usage::"
msgstr ""

#: ../../library/typing.rst:1036
msgid "This means that a point2D TypedDict can have any of the keys omitted. A type checker is only expected to support a literal False or True as the value of the total argument. True is the default, and makes all items defined in the class body be required."
msgstr ""

#: ../../library/typing.rst:1041
msgid "See :pep:`589` for more examples and detailed rules of using ``TypedDict``."
msgstr ""

#: ../../library/typing.rst:1046
msgid "Generic concrete collections"
msgstr ""

#: ../../library/typing.rst:1049
msgid "Corresponding to built-in types"
msgstr ""

#: ../../library/typing.rst:1053
msgid "A generic version of :class:`dict`. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as :class:`Mapping`."
msgstr ""

#: ../../library/typing.rst:1057
msgid "This type can be used as follows::"
msgstr ""

#: ../../library/typing.rst:1062
msgid ":class:`builtins.dict <dict>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1067
msgid "Generic version of :class:`list`. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as :class:`Sequence` or :class:`Iterable`."
msgstr ""

#: ../../library/typing.rst:1072
msgid "This type may be used as follows::"
msgstr ""

#: ../../library/typing.rst:1082
msgid ":class:`builtins.list <list>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1087
msgid "A generic version of :class:`builtins.set <set>`. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as :class:`AbstractSet`."
msgstr ""

#: ../../library/typing.rst:1091
msgid ":class:`builtins.set <set>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1096
msgid "A generic version of :class:`builtins.frozenset <frozenset>`."
msgstr ""

#: ../../library/typing.rst:1098
msgid ":class:`builtins.frozenset <frozenset>` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1101
msgid ":data:`Tuple` is a special form."
msgstr ""

#: ../../library/typing.rst:1104
msgid "Corresponding to types in :mod:`collections`"
msgstr ""

#: ../../library/typing.rst:1108
msgid "A generic version of :class:`collections.defaultdict`."
msgstr ""

#: ../../library/typing.rst:1112
msgid ":class:`collections.defaultdict` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1117
msgid "A generic version of :class:`collections.OrderedDict`."
msgstr ""

#: ../../library/typing.rst:1121
msgid ":class:`collections.OrderedDict` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1126
msgid "A generic version of :class:`collections.ChainMap`."
msgstr ""

#: ../../library/typing.rst:1131
msgid ":class:`collections.ChainMap` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1136
msgid "A generic version of :class:`collections.Counter`."
msgstr ""

#: ../../library/typing.rst:1141
msgid ":class:`collections.Counter` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1146
msgid "A generic version of :class:`collections.deque`."
msgstr ""

#: ../../library/typing.rst:1151
msgid ":class:`collections.deque` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1155
msgid "Other concrete types"
msgstr ""

#: ../../library/typing.rst:1161
msgid "Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and ``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned by :func:`open`. These types are also in the ``typing.io`` namespace."
msgstr ""

#: ../../library/typing.rst:1169
msgid "These type aliases correspond to the return types from :func:`re.compile` and :func:`re.match`.  These types (and the corresponding functions) are generic in ``AnyStr`` and can be made specific by writing ``Pattern[str]``, ``Pattern[bytes]``, ``Match[str]``, or ``Match[bytes]``. These types are also in the ``typing.re`` namespace."
msgstr ""

#: ../../library/typing.rst:1176
msgid "Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1181
msgid "``Text`` is an alias for ``str``. It is provided to supply a forward compatible path for Python 2 code: in Python 2, ``Text`` is an alias for ``unicode``."
msgstr ""

#: ../../library/typing.rst:1185
msgid "Use ``Text`` to indicate that a value must contain a unicode string in a manner that is compatible with both Python 2 and Python 3::"
msgstr ""

#: ../../library/typing.rst:1194
msgid "Abstract Base Classes"
msgstr ""

#: ../../library/typing.rst:1197
msgid "Corresponding to collections in :mod:`collections.abc`"
msgstr ""

#: ../../library/typing.rst:1201
msgid "A generic version of :class:`collections.abc.Set`."
msgstr ""

#: ../../library/typing.rst:1203
msgid ":class:`collections.abc.Set` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1208
msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr ""

#: ../../library/typing.rst:1210
msgid "This type represents the types :class:`bytes`, :class:`bytearray`, and :class:`memoryview` of byte sequences."
msgstr ""

#: ../../library/typing.rst:1213
msgid "As a shorthand for this type, :class:`bytes` can be used to annotate arguments of any of the types mentioned above."
msgstr ""

#: ../../library/typing.rst:1216
msgid ":class:`collections.abc.ByteString` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1221
msgid "A generic version of :class:`collections.abc.Collection`"
msgstr ""

#: ../../library/typing.rst:1225
msgid ":class:`collections.abc.Collection` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1230
msgid "A generic version of :class:`collections.abc.Container`."
msgstr ""

#: ../../library/typing.rst:1232
msgid ":class:`collections.abc.Container` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1237
msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr ""

#: ../../library/typing.rst:1239
msgid ":class:`collections.abc.ItemsView` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1244
msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr ""

#: ../../library/typing.rst:1246
msgid ":class:`collections.abc.KeysView` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1251
msgid "A generic version of :class:`collections.abc.Mapping`. This type can be used as follows::"
msgstr ""

#: ../../library/typing.rst:1257
msgid ":class:`collections.abc.Mapping` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1262
msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr ""

#: ../../library/typing.rst:1264
msgid ":class:`collections.abc.MappingView` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1269
msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr ""

#: ../../library/typing.rst:1271
msgid ":class:`collections.abc.MutableMapping` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1276
msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr ""

#: ../../library/typing.rst:1278
msgid ":class:`collections.abc.MutableSequence` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1283
msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr ""

#: ../../library/typing.rst:1285
msgid ":class:`collections.abc.MutableSet` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1290
msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr ""

#: ../../library/typing.rst:1292
msgid ":class:`collections.abc.Sequence` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1297
msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr ""

#: ../../library/typing.rst:1299
msgid ":class:`collections.abc.ValuesView` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1303
msgid "Corresponding to other types in :mod:`collections.abc`"
msgstr ""

#: ../../library/typing.rst:1307
msgid "A generic version of :class:`collections.abc.Iterable`."
msgstr ""

#: ../../library/typing.rst:1309
msgid ":class:`collections.abc.Iterable` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1314
msgid "A generic version of :class:`collections.abc.Iterator`."
msgstr ""

#: ../../library/typing.rst:1316
msgid ":class:`collections.abc.Iterator` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1321
msgid "A generator can be annotated by the generic type ``Generator[YieldType, SendType, ReturnType]``. For example::"
msgstr ""

#: ../../library/typing.rst:1330
msgid "Note that unlike many other generics in the typing module, the ``SendType`` of :class:`Generator` behaves contravariantly, not covariantly or invariantly."
msgstr ""

#: ../../library/typing.rst:1334
msgid "If your generator will only yield values, set the ``SendType`` and ``ReturnType`` to ``None``::"
msgstr ""

#: ../../library/typing.rst:1342
msgid "Alternatively, annotate your generator as having a return type of either ``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""

#: ../../library/typing.rst:1350
msgid ":class:`collections.abc.Generator` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1355
msgid "An alias to :class:`collections.abc.Hashable`"
msgstr ""

#: ../../library/typing.rst:1359
msgid "A generic version of :class:`collections.abc.Reversible`."
msgstr ""

#: ../../library/typing.rst:1361
msgid ":class:`collections.abc.Reversible` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1366
msgid "An alias to :class:`collections.abc.Sized`"
msgstr ""

#: ../../library/typing.rst:1369
msgid "Asynchronous programming"
msgstr ""

#: ../../library/typing.rst:1373
msgid "A generic version of :class:`collections.abc.Coroutine`. The variance and order of type variables correspond to those of :class:`Generator`, for example::"
msgstr ""

#: ../../library/typing.rst:1386
msgid ":class:`collections.abc.Coroutine` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1391
msgid "An async generator can be annotated by the generic type ``AsyncGenerator[YieldType, SendType]``. For example::"
msgstr ""

#: ../../library/typing.rst:1400
msgid "Unlike normal generators, async generators cannot return a value, so there is no ``ReturnType`` type parameter. As with :class:`Generator`, the ``SendType`` behaves contravariantly."
msgstr ""

#: ../../library/typing.rst:1404
msgid "If your generator will only yield values, set the ``SendType`` to ``None``::"
msgstr ""

#: ../../library/typing.rst:1412
msgid "Alternatively, annotate your generator as having a return type of either ``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""

#: ../../library/typing.rst:1422
msgid ":class:`collections.abc.AsyncGenerator` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1427
msgid "A generic version of :class:`collections.abc.AsyncIterable`."
msgstr ""

#: ../../library/typing.rst:1431
msgid ":class:`collections.abc.AsyncIterable` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1436
msgid "A generic version of :class:`collections.abc.AsyncIterator`."
msgstr ""

#: ../../library/typing.rst:1440
msgid ":class:`collections.abc.AsyncIterator` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1445
msgid "A generic version of :class:`collections.abc.Awaitable`."
msgstr ""

#: ../../library/typing.rst:1449
msgid ":class:`collections.abc.Awaitable` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1454
msgid "Context manager types"
msgstr ""

#: ../../library/typing.rst:1458
msgid "A generic version of :class:`contextlib.AbstractContextManager`."
msgstr ""

#: ../../library/typing.rst:1463
msgid ":class:`contextlib.AbstractContextManager` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1468
msgid "A generic version of :class:`contextlib.AbstractAsyncContextManager`."
msgstr ""

#: ../../library/typing.rst:1473
msgid ":class:`contextlib.AbstractAsyncContextManager` now supports ``[]``. See :pep:`585`."
msgstr ""

#: ../../library/typing.rst:1477
msgid "Protocols"
msgstr ""

#: ../../library/typing.rst:1479
msgid "These protocols are decorated with :func:`runtime_checkable`."
msgstr ""

#: ../../library/typing.rst:1483
msgid "An ABC with one abstract method ``__abs__`` that is covariant in its return type."
msgstr ""

#: ../../library/typing.rst:1488
msgid "An ABC with one abstract method ``__bytes__``."
msgstr ""

#: ../../library/typing.rst:1492
msgid "An ABC with one abstract method ``__complex__``."
msgstr ""

#: ../../library/typing.rst:1496
msgid "An ABC with one abstract method ``__float__``."
msgstr ""

#: ../../library/typing.rst:1500
msgid "An ABC with one abstract method ``__index__``."
msgstr ""

#: ../../library/typing.rst:1506
msgid "An ABC with one abstract method ``__int__``."
msgstr ""

#: ../../library/typing.rst:1510
msgid "An ABC with one abstract method ``__round__`` that is covariant in its return type."
msgstr ""

#: ../../library/typing.rst:1514
msgid "Functions and decorators"
msgstr ""

#: ../../library/typing.rst:1518
msgid "Cast a value to a type."
msgstr ""

#: ../../library/typing.rst:1520
msgid "This returns the value unchanged.  To the type checker this signals that the return value has the designated type, but at runtime we intentionally don't check anything (we want this to be as fast as possible)."
msgstr ""

#: ../../library/typing.rst:1527
msgid "The ``@overload`` decorator allows describing functions and methods that support multiple different combinations of argument types. A series of ``@overload``-decorated definitions must be followed by exactly one non-``@overload``-decorated definition (for the same function/method). The ``@overload``-decorated definitions are for the benefit of the type checker only, since they will be overwritten by the non-``@overload``-decorated definition, while the latter is used at runtime but should be ignored by a type checker.  At runtime, calling a ``@overload``-decorated function directly will raise :exc:`NotImplementedError`. An example of overload that gives a more precise type than can be expressed using a union or a type variable::"
msgstr ""

#: ../../library/typing.rst:1551
msgid "See :pep:`484` for details and comparison with other typing semantics."
msgstr ""

#: ../../library/typing.rst:1555
msgid "A decorator to indicate to type checkers that the decorated method cannot be overridden, and the decorated class cannot be subclassed. For example::"
msgstr ""

#: ../../library/typing.rst:1580
msgid "Decorator to indicate that annotations are not type hints."
msgstr ""

#: ../../library/typing.rst:1582
msgid "This works as class or function :term:`decorator`.  With a class, it applies recursively to all methods defined in that class (but not to methods defined in its superclasses or subclasses)."
msgstr ""

#: ../../library/typing.rst:1586
msgid "This mutates the function(s) in place."
msgstr ""

#: ../../library/typing.rst:1590
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr ""

#: ../../library/typing.rst:1592
msgid "This wraps the decorator with something that wraps the decorated function in :func:`no_type_check`."
msgstr ""

#: ../../library/typing.rst:1597
msgid "Decorator to mark a class or function to be unavailable at runtime."
msgstr ""

#: ../../library/typing.rst:1599
msgid "This decorator is itself not available at runtime. It is mainly intended to mark classes that are defined in type stub files if an implementation returns an instance of a private class::"
msgstr ""

#: ../../library/typing.rst:1610
msgid "Note that returning instances of private classes is not recommended. It is usually preferable to make such classes public."
msgstr ""

#: ../../library/typing.rst:1614
msgid "Introspection helpers"
msgstr ""

#: ../../library/typing.rst:1618
msgid "Return a dictionary containing type hints for a function, method, module or class object."
msgstr ""

#: ../../library/typing.rst:1621
msgid "This is often the same as ``obj.__annotations__``. In addition, forward references encoded as string literals are handled by evaluating them in ``globals`` and ``locals`` namespaces. If necessary, ``Optional[t]`` is added for function and method annotations if a default value equal to ``None`` is set. For a class ``C``, return a dictionary constructed by merging all the ``__annotations__`` along ``C.__mro__`` in reverse order."
msgstr ""

#: ../../library/typing.rst:1629
msgid "The function recursively replaces all ``Annotated[T, ...]`` with ``T``, unless ``include_extras`` is set to ``True`` (see :class:`Annotated` for more information). For example::"
msgstr ""

#: ../../library/typing.rst:1642
msgid "Added ``include_extras`` parameter as part of :pep:`593`."
msgstr ""

#: ../../library/typing.rst:1648
msgid "Provide basic introspection for generic types and special typing forms."
msgstr ""

#: ../../library/typing.rst:1650
msgid "For a typing object of the form ``X[Y, Z, ...]`` these functions return ``X`` and ``(Y, Z, ...)``. If ``X`` is a generic alias for a builtin or :mod:`collections` class, it gets normalized to the original class. For unsupported objects return ``None`` and ``()`` correspondingly. Examples::"
msgstr ""

#: ../../library/typing.rst:1666
msgid "A class used for internal typing representation of string forward references. For example, ``list[\"SomeClass\"]`` is implicitly transformed into ``list[ForwardRef(\"SomeClass\")]``.  This class should not be instantiated by a user, but may be used by introspection tools."
msgstr ""

#: ../../library/typing.rst:1672
msgid "Constant"
msgstr ""

#: ../../library/typing.rst:1676
msgid "A special constant that is assumed to be ``True`` by 3rd party static type checkers. It is ``False`` at runtime. Usage::"
msgstr ""

#: ../../library/typing.rst:1685
msgid "The first type annotation must be enclosed in quotes, making it a \"forward reference\", to hide the ``expensive_mod`` reference from the interpreter runtime.  Type annotations for local variables are not evaluated, so the second annotation does not need to be enclosed in quotes."
msgstr ""

#: ../../library/typing.rst:1692
msgid "If ``from __future__ import annotations`` is used in Python 3.7 or later, annotations are not evaluated at function definition time. Instead, they are stored as strings in ``__annotations__``, This makes it unnecessary to use quotes around the annotation. (see :pep:`563`)."
msgstr ""
