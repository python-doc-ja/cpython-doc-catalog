# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-16 13:40+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: ../../reference/expressions.rst:10
msgid "This chapter explains the meaning of the elements of expressions in Python."
msgstr ""

#: ../../reference/expressions.rst:14
msgid "**Syntax Notes:** In this and the following chapters, extended BNF notation will be used to describe syntax, not lexical analysis.  When (one alternative of) a syntax rule has the form"
msgstr ""

#: ../../reference/expressions.rst:23
msgid "and no semantics are given, the semantics of this form of ``name`` are the same as for ``othername``."
msgstr ""

#: ../../reference/expressions.rst:30
msgid "Arithmetic conversions"
msgstr ""

#: ../../reference/expressions.rst:34
msgid "When a description of an arithmetic operator below uses the phrase \"the numeric arguments are converted to a common type,\" the arguments are coerced using the coercion rules listed at  :ref:`coercion-rules`.  If both arguments are standard numeric types, the following coercions are applied:"
msgstr ""

#: ../../reference/expressions.rst:39
msgid "If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: ../../reference/expressions.rst:41
msgid "otherwise, if either argument is a floating point number, the other is converted to floating point;"
msgstr ""

#: ../../reference/expressions.rst:44
msgid "otherwise, if either argument is a long integer, the other is converted to long integer;"
msgstr ""

#: ../../reference/expressions.rst:47
msgid "otherwise, both must be plain integers and no conversion is necessary."
msgstr ""

#: ../../reference/expressions.rst:49
msgid "Some additional rules apply for certain operators (e.g., a string left argument to the '%' operator). Extensions can define their own coercions."
msgstr ""

#: ../../reference/expressions.rst:56
msgid "Atoms"
msgstr ""

#: ../../reference/expressions.rst:60
msgid "Atoms are the most basic elements of expressions.  The simplest atoms are identifiers or literals.  Forms enclosed in reverse quotes or in parentheses, brackets or braces are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""

#: ../../reference/expressions.rst:75
msgid "Identifiers (Names)"
msgstr ""

#: ../../reference/expressions.rst:81
msgid "An identifier occurring as an atom is a name.  See section :ref:`identifiers` for lexical definition and section :ref:`naming` for documentation of naming and binding."
msgstr ""

#: ../../reference/expressions.rst:87
msgid "When the name is bound to an object, evaluation of the atom yields that object. When a name is not bound, an attempt to evaluate it raises a :exc:`NameError` exception."
msgstr ""

#: ../../reference/expressions.rst:95
msgid "**Private name mangling:** When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a :dfn:`private name` of that class. Private names are transformed to a longer form before code is generated for them.  The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name.  For example, the identifier ``__spam`` occurring in a class named ``Ham`` will be transformed to ``_Ham__spam``.  This transformation is independent of the syntactical context in which the identifier is used.  If the transformed name is extremely long (longer than 255 characters), implementation defined truncation may happen. If the class name consists only of underscores, no transformation is done."
msgstr ""

#: ../../reference/expressions.rst:112
msgid "Literals"
msgstr ""

#: ../../reference/expressions.rst:116
msgid "Python supports string literals and various numeric literals:"
msgstr ""

#: ../../reference/expressions.rst:122
msgid "Evaluation of a literal yields an object of the given type (string, integer, long integer, floating point number, complex number) with the given value.  The value may be approximated in the case of floating point and imaginary (complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: ../../reference/expressions.rst:131
msgid "All literals correspond to immutable data types, and hence the object's identity is less important than its value.  Multiple evaluations of literals with the same value (either the same occurrence in the program text or a different occurrence) may obtain the same object or a different object with the same value."
msgstr ""

#: ../../reference/expressions.rst:141
msgid "Parenthesized forms"
msgstr ""

#: ../../reference/expressions.rst:145
msgid "A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""

#: ../../reference/expressions.rst:150
msgid "A parenthesized expression list yields whatever that expression list yields: if the list contains at least one comma, it yields a tuple; otherwise, it yields the single expression that makes up the expression list."
msgstr ""

#: ../../reference/expressions.rst:156
msgid "An empty pair of parentheses yields an empty tuple object.  Since tuples are immutable, the rules for literals apply (i.e., two occurrences of the empty tuple may or may not yield the same object)."
msgstr ""

#: ../../reference/expressions.rst:164
msgid "Note that tuples are not formed by the parentheses, but rather by use of the comma operator.  The exception is the empty tuple, for which parentheses *are* required --- allowing unparenthesized \"nothing\" in expressions would cause ambiguities and allow common typos to pass uncaught."
msgstr ""

#: ../../reference/expressions.rst:173
msgid "List displays"
msgstr ""

#: ../../reference/expressions.rst:179
msgid "A list display is a possibly empty series of expressions enclosed in square brackets:"
msgstr ""

#: ../../reference/expressions.rst:196
msgid "A list display yields a new list object.  Its contents are specified by providing either a list of expressions or a list comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and placed into the list object in that order.  When a list comprehension is supplied, it consists of a single expression followed by at least one :keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` clauses.  In this case, the elements of the new list are those that would be produced by considering each of the :keyword:`for` or :keyword:`if` clauses a block, nesting from left to right, and evaluating the expression to produce a list element each time the innermost block is reached [#]_."
msgstr ""

#: ../../reference/expressions.rst:211
msgid "Displays for sets and dictionaries"
msgstr ""

#: ../../reference/expressions.rst:213
msgid "For constructing a set or a dictionary Python provides special syntax called \"displays\", each of them in two flavors:"
msgstr ""

#: ../../reference/expressions.rst:216
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: ../../reference/expressions.rst:218
msgid "they are computed via a set of looping and filtering instructions, called a :dfn:`comprehension`."
msgstr ""

#: ../../reference/expressions.rst:221
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: ../../reference/expressions.rst:229
msgid "The comprehension consists of a single expression followed by at least one :keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` clauses. In this case, the elements of the new container are those that would be produced by considering each of the :keyword:`for` or :keyword:`if` clauses a block, nesting from left to right, and evaluating the expression to produce an element each time the innermost block is reached."
msgstr ""

#: ../../reference/expressions.rst:236
msgid "Note that the comprehension is executed in a separate scope, so names assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""

#: ../../reference/expressions.rst:243
msgid "Generator expressions"
msgstr ""

#: ../../reference/expressions.rst:248
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: ../../reference/expressions.rst:253
msgid "A generator expression yields a new generator object.  Its syntax is the same as for comprehensions, except that it is enclosed in parentheses instead of brackets or curly braces."
msgstr ""

#: ../../reference/expressions.rst:257
msgid "Variables used in the generator expression are evaluated lazily when the :meth:`__next__` method is called for generator object (in the same fashion as normal generators).  However, the leftmost :keyword:`for` clause is immediately evaluated, so that an error produced by it can be seen before any other possible error in the code that handles the generator expression.  Subsequent :keyword:`for` clauses cannot be evaluated immediately since they may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in range(10) for y in bar(x))``."
msgstr ""

#: ../../reference/expressions.rst:266
msgid "The parentheses can be omitted on calls with only one argument.  See section :ref:`calls` for the detail."
msgstr ""

#: ../../reference/expressions.rst:272
msgid "Dictionary displays"
msgstr ""

#: ../../reference/expressions.rst:278
msgid "A dictionary display is a possibly empty series of key/datum pairs enclosed in curly braces:"
msgstr ""

#: ../../reference/expressions.rst:287
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: ../../reference/expressions.rst:289
msgid "If a comma-separated sequence of key/datum pairs is given, they are evaluated from left to right to define the entries of the dictionary: each key object is used as a key into the dictionary to store the corresponding datum.  This means that you can specify the same key multiple times in the key/datum list, and the final dictionary's value for that key will be the last one given."
msgstr ""

#: ../../reference/expressions.rst:295
msgid "A dict comprehension, in contrast to list and set comprehensions, needs two expressions separated with a colon followed by the usual \"for\" and \"if\" clauses. When the comprehension is run, the resulting key and value elements are inserted in the new dictionary in the order they are produced."
msgstr ""

#: ../../reference/expressions.rst:303
msgid "Restrictions on the types of the key values are listed earlier in section :ref:`types`.  (To summarize, the key type should be :term:`hashable`, which excludes all mutable objects.)  Clashes between duplicate keys are not detected; the last datum (textually rightmost in the display) stored for a given key value prevails."
msgstr ""

#: ../../reference/expressions.rst:313
msgid "Set displays"
msgstr ""

#: ../../reference/expressions.rst:318
msgid "A set display is denoted by curly braces and distinguishable from dictionary displays by the lack of colons separating keys and values:"
msgstr ""

#: ../../reference/expressions.rst:324
msgid "A set display yields a new mutable set object, the contents being specified by either a sequence of expressions or a comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and added to the set object.  When a comprehension is supplied, the set is constructed from the elements resulting from the comprehension."
msgstr ""

#: ../../reference/expressions.rst:330
msgid "An empty set cannot be constructed with ``{}``; this literal constructs an empty dictionary."
msgstr ""

#: ../../reference/expressions.rst:337
msgid "String conversions"
msgstr ""

#: ../../reference/expressions.rst:345
msgid "A string conversion is an expression list enclosed in reverse (a.k.a. backward) quotes:"
msgstr ""

#: ../../reference/expressions.rst:351
msgid "A string conversion evaluates the contained expression list and converts the resulting object into a string according to rules specific to its type."
msgstr ""

#: ../../reference/expressions.rst:354
msgid "If the object is a string, a number, ``None``, or a tuple, list or dictionary containing only objects whose type is one of these, the resulting string is a valid Python expression which can be passed to the built-in function :func:`eval` to yield an expression with the same value (or an approximation, if floating point numbers are involved)."
msgstr ""

#: ../../reference/expressions.rst:360
msgid "(In particular, converting a string adds quotes around it and converts \"funny\" characters to escape sequences that are safe to print.)"
msgstr ""

#: ../../reference/expressions.rst:365
msgid "Recursive objects (for example, lists or dictionaries that contain a reference to themselves, directly or indirectly) use ``...`` to indicate a recursive reference, and the result cannot be passed to :func:`eval` to get an equal value (:exc:`SyntaxError` will be raised instead)."
msgstr ""

#: ../../reference/expressions.rst:374
msgid "The built-in function :func:`repr` performs exactly the same conversion in its argument as enclosing it in parentheses and reverse quotes does.  The built-in function :func:`str` performs a similar but more user-friendly conversion."
msgstr ""

#: ../../reference/expressions.rst:382
msgid "Yield expressions"
msgstr ""

#: ../../reference/expressions.rst:395
msgid "The :keyword:`yield` expression is only used when defining a generator function, and can only be used in the body of a function definition. Using a :keyword:`yield` expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function."
msgstr ""

#: ../../reference/expressions.rst:400
msgid "When a generator function is called, it returns an iterator known as a generator.  That generator then controls the execution of a generator function. The execution starts when one of the generator's methods is called.  At that time, the execution proceeds to the first :keyword:`yield` expression, where it is suspended again, returning the value of :token:`expression_list` to generator's caller.  By suspended we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack.  When the execution is resumed by calling one of the generator's methods, the function can proceed exactly as if the :keyword:`yield` expression was just another external call. The value of the :keyword:`yield` expression after resuming depends on the method which resumed the execution."
msgstr ""

#: ../../reference/expressions.rst:415
msgid "All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended.  The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller."
msgstr ""

#: ../../reference/expressions.rst:425
msgid "Generator-iterator methods"
msgstr ""

#: ../../reference/expressions.rst:427
msgid "This subsection describes the methods of a generator iterator.  They can be used to control the execution of a generator function."
msgstr ""

#: ../../reference/expressions.rst:430
msgid "Note that calling any of the generator methods below when the generator is already executing raises a :exc:`ValueError` exception."
msgstr ""

#: ../../reference/expressions.rst:438
msgid "Starts the execution of a generator function or resumes it at the last executed :keyword:`yield` expression.  When a generator function is resumed with a :meth:`~generator.next` method, the current :keyword:`yield` expression always evaluates to :const:`None`.  The execution then continues to the next :keyword:`yield` expression, where the generator is suspended again, and the value of the :token:`expression_list` is returned to :meth:`~generator.next`'s caller. If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:451
msgid "Resumes the execution and \"sends\" a value into the generator function.  The ``value`` argument becomes the result of the current :keyword:`yield` expression.  The :meth:`send` method returns the next value yielded by the generator, or raises :exc:`StopIteration` if the generator exits without yielding another value. When :meth:`send` is called to start the generator, it must be called with :const:`None` as the argument, because there is no :keyword:`yield` expression that could receive the value."
msgstr ""

#: ../../reference/expressions.rst:462
msgid "Raises an exception of type ``type`` at the point where generator was paused, and returns the next value yielded by the generator function.  If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised.  If the generator function does not catch the passed-in exception, or raises a different exception, then that exception propagates to the caller."
msgstr ""

#: ../../reference/expressions.rst:473
msgid "Raises a :exc:`GeneratorExit` at the point where the generator function was paused.  If the generator function then raises :exc:`StopIteration` (by exiting normally, or due to already being closed) or :exc:`GeneratorExit` (by not catching the exception), close returns to its caller.  If the generator yields a value, a :exc:`RuntimeError` is raised.  If the generator raises any other exception, it is propagated to the caller.  :meth:`close` does nothing if the generator has already exited due to an exception or normal exit."
msgstr ""

#: ../../reference/expressions.rst:481
msgid "Here is a simple example that demonstrates the behavior of generators and generator functions::"
msgstr ""

#: ../../reference/expressions.rst:512
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ""

#: ../../reference/expressions.rst:512
msgid "The proposal to enhance the API and syntax of generators, making them usable as simple coroutines."
msgstr ""

#: ../../reference/expressions.rst:519
msgid "Primaries"
msgstr ""

#: ../../reference/expressions.rst:523
msgid "Primaries represent the most tightly bound operations of the language. Their syntax is:"
msgstr ""

#: ../../reference/expressions.rst:533
msgid "Attribute references"
msgstr ""

#: ../../reference/expressions.rst:537
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: ../../reference/expressions.rst:547
msgid "The primary must evaluate to an object of a type that supports attribute references, e.g., a module, list, or an instance.  This object is then asked to produce the attribute whose name is the identifier.  If this attribute is not available, the exception :exc:`AttributeError` is raised. Otherwise, the type and value of the object produced is determined by the object.  Multiple evaluations of the same attribute reference may yield different objects."
msgstr ""

#: ../../reference/expressions.rst:558
msgid "Subscriptions"
msgstr ""

#: ../../reference/expressions.rst:571
msgid "A subscription selects an item of a sequence (string, tuple or list) or mapping (dictionary) object:"
msgstr ""

#: ../../reference/expressions.rst:577
msgid "The primary must evaluate to an object of a sequence or mapping type."
msgstr ""

#: ../../reference/expressions.rst:579
msgid "If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key.  (The expression list is a tuple except if it has exactly one item.)"
msgstr ""

#: ../../reference/expressions.rst:584
msgid "If the primary is a sequence, the expression list must evaluate to a plain integer.  If this value is negative, the length of the sequence is added to it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero)."
msgstr ""

#: ../../reference/expressions.rst:595
msgid "A string's items are characters.  A character is not a separate data type but a string of exactly one character."
msgstr ""

#: ../../reference/expressions.rst:602
msgid "Slicings"
msgstr ""

#: ../../reference/expressions.rst:614
msgid "A slicing selects a range of items in a sequence object (e.g., a string, tuple or list).  Slicings may be used as expressions or as targets in assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: ../../reference/expressions.rst:634
msgid "There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing.  Rather than further complicating the syntax, this is disambiguated by defining that in this case the interpretation as a subscription takes priority over the interpretation as a slicing (this is the case if the slice list contains no proper slice nor ellipses).  Similarly, when the slice list has exactly one short slice and no trailing comma, the interpretation as a simple slicing takes priority over that as an extended slicing."
msgstr ""

#: ../../reference/expressions.rst:643
msgid "The semantics for a simple slicing are as follows.  The primary must evaluate to a sequence object.  The lower and upper bound expressions, if present, must evaluate to plain integers; defaults are zero and the ``sys.maxint``, respectively.  If either bound is negative, the sequence's length is added to it.  The slicing now selects all items with index *k* such that ``i <= k < j`` where *i* and *j* are the specified lower and upper bounds.  This may be an empty sequence.  It is not an error if *i* or *j* lie outside the range of valid indexes (such items don't exist so they aren't selected)."
msgstr ""

#: ../../reference/expressions.rst:657
msgid "The semantics for an extended slicing are as follows.  The primary must evaluate to a mapping object, and it is indexed with a key that is constructed from the slice list, as follows.  If the slice list contains at least one comma, the key is a tuple containing the conversion of the slice items; otherwise, the conversion of the lone slice item is the key.  The conversion of a slice item that is an expression is that expression.  The conversion of an ellipsis slice item is the built-in ``Ellipsis`` object.  The conversion of a proper slice is a slice object (see section :ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice.step` attributes are the values of the expressions given as lower bound, upper bound and stride, respectively, substituting ``None`` for missing expressions."
msgstr ""

#: ../../reference/expressions.rst:678
msgid "Calls"
msgstr ""

#: ../../reference/expressions.rst:680
msgid "A call calls a callable object (e.g., a :term:`function`) with a possibly empty series of :term:`arguments <argument>`:"
msgstr ""

#: ../../reference/expressions.rst:697
msgid "A trailing comma may be present after the positional and keyword arguments but does not affect the semantics."
msgstr ""

#: ../../reference/expressions.rst:703
msgid "The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and certain class instances themselves are callable; extensions may define additional callable object types).  All argument expressions are evaluated before the call is attempted.  Please refer to section :ref:`function` for the syntax of formal :term:`parameter` lists."
msgstr ""

#: ../../reference/expressions.rst:710
msgid "If keyword arguments are present, they are first converted to positional arguments, as follows.  First, a list of unfilled slots is created for the formal parameters.  If there are N positional arguments, they are placed in the first N slots.  Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on).  If the slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, the value of the argument is placed in the slot, filling it (even if the expression is ``None``, it fills the slot).  When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition.  (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don't specify an argument value for the corresponding slot; this should usually be avoided.)  If there are any unfilled slots for which no default value is specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of filled slots is used as the argument list for the call."
msgstr ""

#: ../../reference/expressions.rst:730
msgid "An implementation may provide built-in functions whose positional parameters do not have names, even if they are 'named' for the purpose of documentation, and which therefore cannot be supplied by keyword.  In CPython, this is the case for functions implemented in C that use :c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: ../../reference/expressions.rst:736
msgid "If there are more positional arguments than there are formal parameter slots, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``*identifier`` is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments)."
msgstr ""

#: ../../reference/expressions.rst:742
msgid "If any keyword argument does not correspond to a formal parameter name, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``**identifier`` is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments."
msgstr ""

#: ../../reference/expressions.rst:752
msgid "If the syntax ``*expression`` appears in the function call, ``expression`` must evaluate to an iterable.  Elements from this iterable are treated as if they were additional positional arguments; if there are positional arguments *x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, *y1*, ..., *yM*."
msgstr ""

#: ../../reference/expressions.rst:759
msgid "A consequence of this is that although the ``*expression`` syntax may appear *after* some keyword arguments, it is processed *before* the keyword arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: ../../reference/expressions.rst:775
msgid "It is unusual for both keyword arguments and the ``*expression`` syntax to be used in the same call, so in practice this confusion does not arise."
msgstr ""

#: ../../reference/expressions.rst:781
msgid "If the syntax ``**expression`` appears in the function call, ``expression`` must evaluate to a mapping, the contents of which are treated as additional keyword arguments.  In the case of a keyword appearing in both ``expression`` and as an explicit keyword argument, a :exc:`TypeError` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:786
msgid "Formal parameters using the syntax ``*identifier`` or ``**identifier`` cannot be used as positional argument slots or as keyword argument names.  Formal parameters using the syntax ``(sublist)`` cannot be used as keyword argument names; the outermost sublist corresponds to a single unnamed argument slot, and the argument value is assigned to the sublist using the usual tuple assignment rules after all other parameter processing is done."
msgstr ""

#: ../../reference/expressions.rst:793
msgid "A call always returns some value, possibly ``None``, unless it raises an exception.  How this value is computed depends on the type of the callable object."
msgstr ""

#: ../../reference/expressions.rst:797
msgid "If it is---"
msgstr ""

#: ../../reference/expressions.rst:810
msgid "a user-defined function:"
msgstr ""

#: ../../reference/expressions.rst:806
msgid "The code block for the function is executed, passing it the argument list.  The first thing the code block will do is bind the formal parameters to the arguments; this is described in section :ref:`function`.  When the code block executes a :keyword:`return` statement, this specifies the return value of the function call."
msgstr ""

#: ../../reference/expressions.rst:824
msgid "a built-in function or method:"
msgstr ""

#: ../../reference/expressions.rst:823
msgid "The result is up to the interpreter; see :ref:`built-in-funcs` for the descriptions of built-in functions and methods."
msgstr ""

#: ../../reference/expressions.rst:831
msgid "a class object:"
msgstr ""

#: ../../reference/expressions.rst:831
msgid "A new instance of that class is returned."
msgstr ""

#: ../../reference/expressions.rst:841
msgid "a class instance method:"
msgstr ""

#: ../../reference/expressions.rst:839
msgid "The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument."
msgstr ""

#: ../../reference/expressions.rst:850
msgid "a class instance:"
msgstr ""

#: ../../reference/expressions.rst:848
msgid "The class must define a :meth:`__call__` method; the effect is then the same as if that method was called."
msgstr ""

#: ../../reference/expressions.rst:855
msgid "The power operator"
msgstr ""

#: ../../reference/expressions.rst:857
msgid "The power operator binds more tightly than unary operators on its left; it binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: ../../reference/expressions.rst:863
msgid "Thus, in an unparenthesized sequence of power and unary operators, the operators are evaluated from right to left (this does not constrain the evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: ../../reference/expressions.rst:867
msgid "The power operator has the same semantics as the built-in :func:`pow` function, when called with two arguments: it yields its left argument raised to the power of its right argument.  The numeric arguments are first converted to a common type.  The result type is that of the arguments after coercion."
msgstr ""

#: ../../reference/expressions.rst:872
msgid "With mixed operand types, the coercion rules for binary arithmetic operators apply. For int and long int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. (This last feature was added in Python 2.2. In Python 2.1 and before, if both arguments were of integer types and the second argument was negative, an exception was raised)."
msgstr ""

#: ../../reference/expressions.rst:881
msgid "Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. Raising a negative number to a fractional power results in a :exc:`ValueError`."
msgstr ""

#: ../../reference/expressions.rst:888
msgid "Unary arithmetic and bitwise operations"
msgstr ""

#: ../../reference/expressions.rst:894
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""

#: ../../reference/expressions.rst:903
msgid "The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""

#: ../../reference/expressions.rst:907
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: ../../reference/expressions.rst:911
msgid "The unary ``~`` (invert) operator yields the bitwise inversion of its plain or long integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  It only applies to integral numbers."
msgstr ""

#: ../../reference/expressions.rst:917
msgid "In all three cases, if the argument does not have the proper type, a :exc:`TypeError` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:924
msgid "Binary arithmetic operations"
msgstr ""

#: ../../reference/expressions.rst:928
msgid "The binary arithmetic operations have the conventional priority levels.  Note that some of these operations also apply to certain non-numeric types.  Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators:"
msgstr ""

#: ../../reference/expressions.rst:940
msgid "The ``*`` (multiplication) operator yields the product of its arguments.  The arguments must either both be numbers, or one argument must be an integer (plain or long) and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together.  In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence."
msgstr ""

#: ../../reference/expressions.rst:951
msgid "The ``/`` (division) and ``//`` (floor division) operators yield the quotient of their arguments.  The numeric arguments are first converted to a common type. Plain or long integer division yields an integer of the same type; the result is that of mathematical division with the 'floor' function applied to the result. Division by zero raises the :exc:`ZeroDivisionError` exception."
msgstr ""

#: ../../reference/expressions.rst:959
msgid "The ``%`` (modulo) operator yields the remainder from the division of the first argument by the second.  The numeric arguments are first converted to a common type.  A zero right argument raises the :exc:`ZeroDivisionError` exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo operator always yields a result with the same sign as its second operand (or zero); the absolute value of the result is strictly smaller than the absolute value of the second operand [#]_."
msgstr ""

#: ../../reference/expressions.rst:968
msgid "The integer division and modulo operators are connected by the following identity: ``x == (x/y)*y + (x%y)``.  Integer division and modulo are also connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x/y, x%y)``.  These identities don't hold for floating point numbers; there similar identities hold approximately where ``x/y`` is replaced by ``floor(x/y)`` or ``floor(x/y) - 1`` [#]_."
msgstr ""

#: ../../reference/expressions.rst:975
msgid "In addition to performing the modulo operation on numbers, the ``%`` operator is also overloaded by string and unicode objects to perform string formatting (also known as interpolation). The syntax for string formatting is described in the Python Library Reference, section :ref:`string-formatting`."
msgstr ""

#: ../../reference/expressions.rst:980
msgid "The floor division operator, the modulo operator, and the :func:`divmod` function are no longer defined for complex numbers.  Instead, convert to a floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../reference/expressions.rst:987
msgid "The ``+`` (addition) operator yields the sum of its arguments. The arguments must either both be numbers or both sequences of the same type.  In the former case, the numbers are converted to a common type and then added together.  In the latter case, the sequences are concatenated."
msgstr ""

#: ../../reference/expressions.rst:994
msgid "The ``-`` (subtraction) operator yields the difference of its arguments.  The numeric arguments are first converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1001
msgid "Shifting operations"
msgstr ""

#: ../../reference/expressions.rst:1005
msgid "The shifting operations have lower priority than the arithmetic operations:"
msgstr ""

#: ../../reference/expressions.rst:1010
msgid "These operators accept plain or long integers as arguments.  The arguments are converted to a common type.  They shift the first argument to the left or right by the number of bits given by the second argument."
msgstr ""

#: ../../reference/expressions.rst:1016
msgid "A right shift by *n* bits is defined as division by ``pow(2, n)``.  A left shift by *n* bits is defined as multiplication with ``pow(2, n)``.  Negative shift counts raise a :exc:`ValueError` exception."
msgstr ""

#: ../../reference/expressions.rst:1022
msgid "In the current implementation, the right-hand operand is required to be at most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:1029
msgid "Binary bitwise operations"
msgstr ""

#: ../../reference/expressions.rst:1033
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: ../../reference/expressions.rst:1042
msgid "The ``&`` operator yields the bitwise AND of its arguments, which must be plain or long integers.  The arguments are converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1049
msgid "The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, which must be plain or long integers.  The arguments are converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1056
msgid "The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which must be plain or long integers.  The arguments are converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1063
msgid "Comparisons"
msgstr ""

#: ../../reference/expressions.rst:1069
msgid "Unlike C, all comparison operations in Python have the same priority, which is lower than that of any arithmetic, shifting or bitwise operation.  Also unlike C, expressions like ``a < b < c`` have the interpretation that is conventional in mathematics:"
msgstr ""

#: ../../reference/expressions.rst:1079
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: ../../reference/expressions.rst:1083
msgid "Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in both cases ``z`` is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""

#: ../../reference/expressions.rst:1087
msgid "Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each expression is evaluated at most once."
msgstr ""

#: ../../reference/expressions.rst:1092
msgid "Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not pretty)."
msgstr ""

#: ../../reference/expressions.rst:1096
msgid "The forms ``<>`` and ``!=`` are equivalent; for consistency with C, ``!=`` is preferred; where ``!=`` is mentioned below ``<>`` is also accepted.  The ``<>`` spelling is considered obsolescent."
msgstr ""

#: ../../reference/expressions.rst:1101
msgid "Value comparisons"
msgstr ""

#: ../../reference/expressions.rst:1103
msgid "The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the values of two objects.  The objects do not need to have the same type."
msgstr ""

#: ../../reference/expressions.rst:1106
msgid "Chapter :ref:`objects` states that objects have a value (in addition to type and identity).  The value of an object is a rather abstract notion in Python: For example, there is no canonical access method for an object's value.  Also, there is no requirement that the value of an object should be constructed in a particular way, e.g. comprised of all its data attributes. Comparison operators implement a particular notion of what the value of an object is.  One can think of them as defining the value of an object indirectly, by means of their comparison implementation."
msgstr ""

#: ../../reference/expressions.rst:1115
msgid "Types can customize their comparison behavior by implementing a :meth:`__cmp__` method or :dfn:`rich comparison methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""

#: ../../reference/expressions.rst:1120
msgid "The default behavior for equality comparison (``==`` and ``!=``) is based on the identity of the objects.  Hence, equality comparison of instances with the same identity results in equality, and equality comparison of instances with different identities results in inequality.  A motivation for this default behavior is the desire that all objects should be reflexive (i.e. ``x is y`` implies ``x == y``)."
msgstr ""

#: ../../reference/expressions.rst:1127
msgid "The default order comparison (``<``, ``>``, ``<=``, and ``>=``) gives a consistent but arbitrary order."
msgstr ""

#: ../../reference/expressions.rst:1130
msgid "(This unusual definition of comparison was used to simplify the definition of operations like sorting and the :keyword:`in` and :keyword:`not in` operators. In the future, the comparison rules for objects of different types are likely to change.)"
msgstr ""

#: ../../reference/expressions.rst:1135
msgid "The behavior of the default equality comparison, that instances with different identities are always unequal, may be in contrast to what types will need that have a sensible definition of object value and value-based equality.  Such types will need to customize their comparison behavior, and in fact, a number of built-in types have done that."
msgstr ""

#: ../../reference/expressions.rst:1141
msgid "The following list describes the comparison behavior of the most important built-in types."
msgstr ""

#: ../../reference/expressions.rst:1144
msgid "Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can be compared within and across their types, with the restriction that complex numbers do not support order comparison.  Within the limits of the types involved, they compare mathematically (algorithmically) correct without loss of precision."
msgstr ""

#: ../../reference/expressions.rst:1151
msgid "Strings (instances of :class:`str` or :class:`unicode`) compare lexicographically using the numeric equivalents (the result of the built-in function :func:`ord`) of their characters. [#]_ When comparing an 8-bit string and a Unicode string, the 8-bit string is converted to Unicode.  If the conversion fails, the strings are considered unequal."
msgstr ""

#: ../../reference/expressions.rst:1158
msgid "Instances of :class:`tuple` or :class:`list` can be compared only within each of their types.  Equality comparison across these types results in unequality, and ordering comparison across these types gives an arbitrary order."
msgstr ""

#: ../../reference/expressions.rst:1163
msgid "These sequences compare lexicographically using comparison of corresponding elements, whereby reflexivity of the elements is enforced."
msgstr ""

#: ../../reference/expressions.rst:1166
msgid "In enforcing reflexivity of elements, the comparison of collections assumes that for a collection element ``x``, ``x == x`` is always true.  Based on that assumption, element identity is compared first, and element comparison is performed only for distinct elements.  This approach yields the same result as a strict element comparison would, if the compared elements are reflexive.  For non-reflexive elements, the result is different than for strict element comparison."
msgstr ""

#: ../../reference/expressions.rst:1174
msgid "Lexicographical comparison between built-in collections works as follows:"
msgstr ""

#: ../../reference/expressions.rst:1176
msgid "For two collections to compare equal, they must be of the same type, have the same length, and each pair of corresponding elements must compare equal (for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""

#: ../../reference/expressions.rst:1181
msgid "Collections are ordered the same as their first unequal elements (for example, ``cmp([1,2,x], [1,2,y])`` returns the same as ``cmp(x,y)``).  If a corresponding element does not exist, the shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is true)."
msgstr ""

#: ../../reference/expressions.rst:1187
msgid "Mappings (instances of :class:`dict`) compare equal if and only if they have equal `(key, value)` pairs. Equality comparison of the keys and values enforces reflexivity."
msgstr ""

#: ../../reference/expressions.rst:1191
msgid "Outcomes other than equality are resolved consistently, but are not otherwise defined. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1194
msgid "Most other objects of built-in types compare unequal unless they are the same object; the choice whether one object is considered smaller or larger than another one is made arbitrarily but consistently within one execution of a program."
msgstr ""

#: ../../reference/expressions.rst:1199
msgid "User-defined classes that customize their comparison behavior should follow some consistency rules, if possible:"
msgstr ""

#: ../../reference/expressions.rst:1202
msgid "Equality comparison should be reflexive. In other words, identical objects should compare equal:"
msgstr ""

#: ../../reference/expressions.rst:1205
msgid "``x is y`` implies ``x == y``"
msgstr ""

#: ../../reference/expressions.rst:1207
msgid "Comparison should be symmetric. In other words, the following expressions should have the same result:"
msgstr ""

#: ../../reference/expressions.rst:1210
msgid "``x == y`` and ``y == x``"
msgstr ""

#: ../../reference/expressions.rst:1212
msgid "``x != y`` and ``y != x``"
msgstr ""

#: ../../reference/expressions.rst:1214
msgid "``x < y`` and ``y > x``"
msgstr ""

#: ../../reference/expressions.rst:1216
msgid "``x <= y`` and ``y >= x``"
msgstr ""

#: ../../reference/expressions.rst:1218
msgid "Comparison should be transitive. The following (non-exhaustive) examples illustrate that:"
msgstr ""

#: ../../reference/expressions.rst:1221
msgid "``x > y and y > z`` implies ``x > z``"
msgstr ""

#: ../../reference/expressions.rst:1223
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr ""

#: ../../reference/expressions.rst:1225
msgid "Inverse comparison should result in the boolean negation. In other words, the following expressions should have the same result:"
msgstr ""

#: ../../reference/expressions.rst:1228
msgid "``x == y`` and ``not x != y``"
msgstr ""

#: ../../reference/expressions.rst:1230
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr ""

#: ../../reference/expressions.rst:1232
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr ""

#: ../../reference/expressions.rst:1234
msgid "The last two expressions apply to totally ordered collections (e.g. to sequences, but not to sets or mappings). See also the :func:`~functools.total_ordering` decorator."
msgstr ""

#: ../../reference/expressions.rst:1238
msgid "The :func:`hash` result should be consistent with equality. Objects that are equal should either have the same hash value, or be marked as unhashable."
msgstr ""

#: ../../reference/expressions.rst:1242
msgid "Python does not enforce these consistency rules."
msgstr ""

#: ../../reference/expressions.rst:1250
msgid "Membership test operations"
msgstr ""

#: ../../reference/expressions.rst:1252
msgid "The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in sequences and set types support this as well as dictionary, for which :keyword:`in` tests whether the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""

#: ../../reference/expressions.rst:1260
msgid "For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings are always considered to be a substring of any other string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""

#: ../../reference/expressions.rst:1265
msgid "For user-defined classes which define the :meth:`__contains__` method, ``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and ``False`` otherwise."
msgstr ""

#: ../../reference/expressions.rst:1269
msgid "For user-defined classes which do not define :meth:`__contains__` but do define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z`` with ``x == z`` is produced while iterating over ``y``.  If an exception is raised during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""

#: ../../reference/expressions.rst:1274
msgid "Lastly, the old-style iteration protocol is tried: if a class defines :meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative integer index *i* such that ``x == y[i]``, and all lower integer indices do not raise :exc:`IndexError` exception. (If any other exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""

#: ../../reference/expressions.rst:1286
msgid "The operator :keyword:`not in` is defined to have the inverse true value of :keyword:`in`."
msgstr ""

#: ../../reference/expressions.rst:1299
msgid "Identity comparisons"
msgstr ""

#: ../../reference/expressions.rst:1301
msgid "The operators :keyword:`is` and :keyword:`is not` test for object identity: ``x is y`` is true if and only if *x* and *y* are the same object.  ``x is not y`` yields the inverse truth value. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1312
msgid "Boolean operations"
msgstr ""

#: ../../reference/expressions.rst:1323
msgid "In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: ``False``, ``None``, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets).  All other values are interpreted as true.  (See the :meth:`~object.__nonzero__` special method for a way to change this.)"
msgstr ""

#: ../../reference/expressions.rst:1332
msgid "The operator :keyword:`not` yields ``True`` if its argument is false, ``False`` otherwise."
msgstr ""

#: ../../reference/expressions.rst:1337
msgid "The expression ``x and y`` first evaluates *x*; if *x* is false, its value is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: ../../reference/expressions.rst:1342
msgid "The expression ``x or y`` first evaluates *x*; if *x* is true, its value is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: ../../reference/expressions.rst:1345
msgid "(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and type they return to ``False`` and ``True``, but rather return the last evaluated argument. This is sometimes useful, e.g., if ``s`` is a string that should be replaced by a default value if it is empty, the expression ``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to invent a value anyway, it does not bother to return a value of the same type as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""

#: ../../reference/expressions.rst:1355
msgid "Conditional Expressions"
msgstr ""

#: ../../reference/expressions.rst:1367
msgid "Conditional expressions (sometimes called a \"ternary operator\") have the lowest priority of all Python operations."
msgstr ""

#: ../../reference/expressions.rst:1370
msgid "The expression ``x if C else y`` first evaluates the condition, *C* (*not* *x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, *y* is evaluated and its value is returned."
msgstr ""

#: ../../reference/expressions.rst:1374
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

#: ../../reference/expressions.rst:1381
msgid "Lambdas"
msgstr ""

#: ../../reference/expressions.rst:1391
msgid "Lambda expressions (sometimes called lambda forms) have the same syntactic position as expressions.  They are a shorthand to create anonymous functions; the expression ``lambda parameters: expression`` yields a function object.  The unnamed object behaves like a function object defined with ::"
msgstr ""

#: ../../reference/expressions.rst:1399
msgid "See section :ref:`function` for the syntax of parameter lists.  Note that functions created with lambda expressions cannot contain statements."
msgstr ""

#: ../../reference/expressions.rst:1406
msgid "Expression lists"
msgstr ""

#: ../../reference/expressions.rst:1415
msgid "An expression list containing at least one comma yields a tuple.  The length of the tuple is the number of expressions in the list.  The expressions are evaluated from left to right."
msgstr ""

#: ../../reference/expressions.rst:1421
msgid "The trailing comma is required only to create a single tuple (a.k.a. a *singleton*); it is optional in all other cases.  A single expression without a trailing comma doesn't create a tuple, but rather yields the value of that expression. (To create an empty tuple, use an empty pair of parentheses: ``()``.)"
msgstr ""

#: ../../reference/expressions.rst:1431
msgid "Evaluation order"
msgstr ""

#: ../../reference/expressions.rst:1435
msgid "Python evaluates expressions from left to right. Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side."
msgstr ""

#: ../../reference/expressions.rst:1438
msgid "In the following lines, expressions will be evaluated in the arithmetic order of their suffixes::"
msgstr ""

#: ../../reference/expressions.rst:1452
msgid "Operator precedence"
msgstr ""

#: ../../reference/expressions.rst:1456
msgid "The following table summarizes the operator precedences in Python, from lowest precedence (least binding) to highest precedence (most binding). Operators in the same box have the same precedence.  Unless the syntax is explicitly given, operators are binary.  Operators in the same box group left to right (except for comparisons, including tests, which all have the same precedence and chain from left to right --- see section :ref:`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""

#: ../../reference/expressions.rst:1465
msgid "Operator"
msgstr ""

#: ../../reference/expressions.rst:1465
msgid "Description"
msgstr ""

#: ../../reference/expressions.rst:1467
msgid ":keyword:`lambda`"
msgstr ""

#: ../../reference/expressions.rst:1467
msgid "Lambda expression"
msgstr ""

#: ../../reference/expressions.rst:1469
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ""

#: ../../reference/expressions.rst:1469
msgid "Conditional expression"
msgstr ""

#: ../../reference/expressions.rst:1471
msgid ":keyword:`or`"
msgstr ""

#: ../../reference/expressions.rst:1471
msgid "Boolean OR"
msgstr ""

#: ../../reference/expressions.rst:1473
msgid ":keyword:`and`"
msgstr ""

#: ../../reference/expressions.rst:1473
msgid "Boolean AND"
msgstr ""

#: ../../reference/expressions.rst:1475
msgid ":keyword:`not` ``x``"
msgstr ""

#: ../../reference/expressions.rst:1475
msgid "Boolean NOT"
msgstr ""

#: ../../reference/expressions.rst:1477
msgid ":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, ``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"
msgstr ""

#: ../../reference/expressions.rst:1477
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: ../../reference/expressions.rst:1481
msgid "``|``"
msgstr ""

#: ../../reference/expressions.rst:1481
msgid "Bitwise OR"
msgstr ""

#: ../../reference/expressions.rst:1483
msgid "``^``"
msgstr ""

#: ../../reference/expressions.rst:1483
msgid "Bitwise XOR"
msgstr ""

#: ../../reference/expressions.rst:1485
msgid "``&``"
msgstr ""

#: ../../reference/expressions.rst:1485
msgid "Bitwise AND"
msgstr ""

#: ../../reference/expressions.rst:1487
msgid "``<<``, ``>>``"
msgstr ""

#: ../../reference/expressions.rst:1487
msgid "Shifts"
msgstr ""

#: ../../reference/expressions.rst:1489
msgid "``+``, ``-``"
msgstr ""

#: ../../reference/expressions.rst:1489
msgid "Addition and subtraction"
msgstr ""

#: ../../reference/expressions.rst:1491
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: ../../reference/expressions.rst:1491
msgid "Multiplication, division, remainder [#]_"
msgstr ""

#: ../../reference/expressions.rst:1494
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: ../../reference/expressions.rst:1494
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: ../../reference/expressions.rst:1496
msgid "``**``"
msgstr ""

#: ../../reference/expressions.rst:1496
msgid "Exponentiation [#]_"
msgstr ""

#: ../../reference/expressions.rst:1498
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: ../../reference/expressions.rst:1498
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: ../../reference/expressions.rst:1501
msgid "``(expressions...)``, ``[expressions...]``, ``{key: value...}``, ```expressions...```"
msgstr ""

#: ../../reference/expressions.rst:1501
msgid "Binding or tuple display, list display, dictionary display, string conversion"
msgstr ""

#: ../../reference/expressions.rst:1508
msgid "Footnotes"
msgstr ""

#: ../../reference/expressions.rst:1509
msgid "In Python 2.3 and later releases, a list comprehension \"leaks\" the control variables of each ``for`` it contains into the containing scope.  However, this behavior is deprecated, and relying on it will not work in Python 3."
msgstr ""

#: ../../reference/expressions.rst:1513
msgid "While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be true numerically due to roundoff.  For example, and assuming a platform on which a Python float is an IEEE 754 double-precision number, in order that ``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is ``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The function :func:`math.fmod` returns a result whose sign matches the sign of the first argument instead, and so returns ``-1e-100`` in this case. Which approach is more appropriate depends on the application."
msgstr ""

#: ../../reference/expressions.rst:1522
msgid "If x is very close to an exact integer multiple of y, it's possible for ``floor(x/y)`` to be one larger than ``(x-x%y)/y`` due to rounding.  In such cases, Python returns the latter result, in order to preserve that ``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""

#: ../../reference/expressions.rst:1527
msgid "The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most abstract characters in Unicode are only represented using one code point, there is a number of abstract characters that can in addition be represented using a sequence of more than one code point.  For example, the abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a single :dfn:`precomposed character` at code position U+00C7, or as a sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL LETTER C), followed by a :dfn:`combining character` at code position U+0327 (COMBINING CEDILLA)."
msgstr ""

#: ../../reference/expressions.rst:1538
msgid "The comparison operators on unicode strings compare at the level of Unicode code points. This may be counter-intuitive to humans.  For example, ``u\"\\u00C7\" == u\"\\u0043\\u0327\"`` is ``False``, even though both strings represent the same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""

#: ../../reference/expressions.rst:1543
msgid "To compare strings at the level of abstract characters (that is, in a way intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""

#: ../../reference/expressions.rst:1546
msgid "Earlier versions of Python used lexicographic comparison of the sorted (key, value) lists, but this was very expensive for the common case of comparing for equality.  An even earlier version of Python compared dictionaries by identity only, but this caused surprises because people expected to be able to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""

#: ../../reference/expressions.rst:1552
msgid "Due to automatic garbage-collection, free lists, and the dynamic nature of descriptors, you may notice seemingly unusual behaviour in certain uses of the :keyword:`is` operator, like those involving comparisons between instance methods, or constants.  Check their documentation for more info."
msgstr ""

#: ../../reference/expressions.rst:1557
msgid "The ``%`` operator is also used for string formatting; the same precedence applies."
msgstr ""

#: ../../reference/expressions.rst:1560
msgid "The power operator ``**`` binds less tightly than an arithmetic or bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""

